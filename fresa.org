#+INCLUDE:   /home/ucecesf/hg/homepages/level-0.org
#+title: Fresa, a plant propagation algorithm
#+options: num:nil ^:nil toc:nil tex:imagemagick

| *Author*        | {{{author}}} ({{{email}}})                   |
| *Last revision* | {{{modification-time(%Y-%m-%d %H:%M:%S,t)}}} |

#+toc: headlines 1

* Overview and introduction
/Fresa/ is an implementation of a /plant propagation algorithm/ in [[http://www.julialang.org/][Julia]] programming language.  Our original version was called [[file:strawberry.org][Strawberry]], written in Octave (and usable in MATLAB).  Please see the [[file:strawberry.org][documentation]] of Strawberry for a longer description of the history of these codes, the conditions on which you may use these codes and which articles to cite.

This document has been written using [[http://orgmode.org/][org mode]] in the [[https://www.gnu.org/software/emacs/][Emacs]] text editor.  Org allows for /literate programming/ and uses /tangling/ to generate the actual source files for the code.  The code, tangled from this file, can be found here: call_distribution().

All code (either version) is copyright Â© 2016, Eric S Fraga, all rights reserved.  Permission is given to use this code for evaluation purposes. The code is made available with no warranty or guarantee of any kind.  Use at own risk.  

Please let [[mailto:e.fraga@ucl.ac.uk?subject=The%20Strawberry%20code][the author know]] if you download the code.  Further, if either /Fresa/ or /Strawberry/ codes are sed, please do let the authors know and the [[file:strawberry.org][publications]] must be cited in any research papers written.  Feedback, including bug reports, is most welcome.

In the following code, we assume column vectors for decision variables and objectives.  The convention on constraint violation is 1 meaning yes, i.e. infeasible solution, and 0 means no violation of the constraints.

** Upload to web site                                        :noexport:
#+begin_src shell :results none :exports none
  scp -r fresa.org fresa.html Fresa.jl ltximg socrates.ucl.ac.uk:html.pub
#+end_src
** Code for creating a distribution                          :noexport:
#+name: distribution
#+begin_src shell :results output raw :exports results
  echo [[file:./Fresa.jl][Fresa.jl]]
#+end_src 

#+results: distribution
[[file:./fresa.jl][fresa.jl]]

* Version information

Major version log:

- November 2016 :: first [[http://www.julialang.org/][Julia]] plant propagation algorithm implementation.
* TODO [0/0] improvements or bugs                            :noexport:
* Fresa
:PROPERTIES:
:header-args: :tangle "Fresa.jl"
:END:
#+toc: headlines 2 local
** start of module
#+name: modulestart
#+begin_src julia
  module Fresa

  version = "2016.11.18 15:51:07"
  function __init__()
      println("Fresa PPA $version")
  end
#+end_src
** variables
#+name: variables
#+begin_src julia
  a = 0                           # lower bounds
  b = 1                           # upper bounds
  m = 1                           # objective functions
  n = 1                           # number of decision variables
  npruned = 0
  nsimilar = 0
  ns = 100                        # stopping criterion
  nrmax = 5                       # number of runners
  npop = 10                       # population size
  ngen = 100                      # stopping criterion
  output = 5                      # how often to output
  population_strategy = 4         # new population definition
#+end_src 
** fitness
#+name: fitness
#+begin_src julia
  function fitness(pop)
      k, l = size(pop)
      global m = k-n-1
      # println(": $m objective functions with $l members in population")
      if 1 == m
          s = sortperm(pop[n+1,:])
          zmin = pop[n+1,s[1]]
          zmax = pop[n+1,s[l]]
          # println(": objective function values in range [$zmin,$zmax]")
          if l == 1 || abs(zmax-zmin) < eps()
              fit = 0.5*ones(l)
          else
              fit = tanh((zmax - pop[n+1,:]) / (zmax - zmin) - 0.5)+0.5
              # println("Fitness $f")
          end
      else
          z = pop[n+1:n+m,:]
          rank = ones(m,l);      #rank of each solution for each objective function 
          for i=1:m
              rank[i,sortperm(z[i,:])] = 1:l;
          end
          # hadamard product of ranks
          fitness = map(x->prod(x), rank[:,i] for i=1:l)
          # normalise and reverse meaning (1=best, 0=worst)
          if l == 1
              fit = [0.5]
          else
              fit = 1 - fitness / maximum(fitness);
          end
      end
      fit
  end
#+end_src 
** neighbour -- default for real valued decision vectors
#+name: neighbour
#+begin_src julia
  function neighbour(x,f)
      nx = x .+ (1-f) * 2(rand(n,1)-0.5) .* (b-a)
      nx[nx.<a] = a[nx.<a];
      nx[nx.>b] = b[nx.>b];
      return nx
  end
#+end_src
** pareto -- return set of non-dominated points in population
#+name: pareto
#+begin_src julia
  function pareto(pop)
      k, l = size(pop)
      m = k-n-1                   # number of objectives
      z = pop[n+1:n+m,:]
      p = pop[:,1]                # pareto front
      first = true
      for i in 1:l
          dominated = false
          for j in 1:l
              if i != j
                  if all(z[:,i] .>= z[:,j])
                      # println("$i dominated by $j")
                      # println("$(z[:,i]) >= $(z[:,j])")
                      dominated = true;
                      break;
                  end
              end
          end
          # println("member $(pop[:,i]) is dominated: $dominated")
          if !dominated
              if first
                  p[:,1] = pop[:,i]
                  first = false
              else
                  p = hcat(p,pop[:,i])
              end
          end
      end
      p
  end

#+end_src 
** select -- default selection method using size 2 tournament selection
#+name: select
#+begin_src julia
  function select(f)
      l = length(f)
      ind1 = rand(1:l)
      if ind1 == 0
          ind1 = 1
      end
      ind2 = rand(1:l)
      # println("Comparing $ind1 to $ind2")
      if f[ind1] > f[ind2]
          return ind1
      else
          return ind2
      end
  end
#+end_src 
** set bounds -- for real valued decision vectors
Mostly for testing as bounds will form part of the main method call.
#+name: setbounds
#+begin_src julia
  function setbounds(lower,upper)
      global a = lower;
      global b = upper;
      global n = length(lower);
      println("Size of problem: $n")
  end
#+end_src
** solve -- use the PPA to solve the optimisation problem
The function expects the objective function, ~f~, an initial guess, ~x0~, and lower, ~a~, and upper, ~b~, bounds.  It returns the optimum, the objective function value(s) at this point, the constraint at that point and the whole population at the end.
#+name: solve
#+begin_src julia
  function solve(f,x0,a,b)
      tstart = time()
      setbounds(a,b)
      z, g = f(x0)
      println(": f($x0) = $z with constraint $g")
      m = length(z)
      println(": there are $m objective functions.")
      pop = [x0;z;g]
      for gen in 1:ngen
          fit = fitness(pop)
          index = sortperm(fit)
          best = pop[:,index[length(fit)]]
          print(": $gen best is $(best[n+1:n+m+1])\r")
          if gen%output == 0
              @printf("| %9d | %9.2f | ", gen, time()-tstart)
              j = m>1 ? n+1 : 1
              for i=j:n+m+1
                  @printf("%9g |", best[i])
              end
              println()
          end
          newpop = best
          k, l = size(pop)
          for i in 1:min(l,npop)
              s = select(fit)
              # println(": selection $i is $s")
              # println(": size of pop is $(size(pop))")
              selected = pop[:,s]
              newpop = hcat(newpop,selected)
              nr = ceil(fit[s]*nrmax*rand())
              if nr < 1
                  nr = 1
              end
              # println(": generating $nr runners")
              for r in 1:nr
                  x = neighbour(pop[1:n,s],fit[s])
                  z, g = f(x)
                  newpop = hcat(newpop,[x;z;g])
              end
          end
          pop = newpop;
      end
      fit = fitness(pop)
      index = sortperm(fit)
      if m == 1
          best = pop[:,index[length(fit)]]
          return best[1:n], best[n+1:n+m], best[n+m+1], pop
      else
          return pareto(pop), pop
      end
  end
#+end_src 
** module end
#+name: moduleend
#+begin_src julia
  end
#+end_src
* tests
#+toc: headlines 2 local
** neighbour
#+name: testneighbour
#+begin_src julia :tangle testneighbour.jl
  using Fresa
  a = -5*ones(5,1)
  b = 5*ones(5,1)
  x = a + (b-a) .* rand(5,1)
  println("$x")
  Fresa.setbounds(a,b)
  for i in 1:10
      print("$i: ")
      n = Fresa.neighbour(x,0.9)
      println("$n")
  end
#+end_src
** fitness test
This test uses a simple quadratic objective function to test out the fitness evaluation.
#+name: testfitness
#+begin_src julia :tangle testfitness.jl
  using Fresa
  x0 = 0.5*ones(2,1)
  a = zeros(2,1)
  b = 10*ones(2,1)
  Fresa.setbounds(a,b)
  f(x) = ((x[1]-3)^2+(x[2]-5)^2+8, 0)
  z, g = f(x0)
  pop = [x0;z;g]
  for i in 1:5
      x = Fresa.neighbour(x0,0.5)
      z, g = f(x)
      pop = hcat(pop, [x;z;g])
      npop = size(pop)
      l = length(pop)
      println("Population size $npop with length $l")
  end
  z = pop[3,:]
  println("Objective function values: $z")
  fit = Fresa.fitness(pop)
  println("Fitness: $fit")
  for i in 1:5
      index = Fresa.select(fit)
      println("$i selected $index")
  end
#+end_src
** multi-objective test
#+name: testmultiobjective
#+begin_src julia :tangle testmultiobjective.jl
  using Fresa
  a = zeros(2,1)
  b = ones(2,1)
  x = rand(2,1)
  f(x) = ( [sin(x[1]-x[2]); cos(x[1]+x[2])], 0)
  pareto, population = Fresa.solve(f, x, a, b)

  println("Pareto front:")
  println(pareto)

  using PyPlot
  PyPlot.plot(pareto[3,:], pareto[4,:], "ro")
  PyPlot.savefig("x.pdf")
#+end_src 
** multi-objective test with 3 objectives
#+name: testmultiobjective3
#+begin_src julia :tangle testmultiobjective3.jl
  using Fresa
  n = 5
  a = zeros(n,1)
  b = ones(n,1)
  x = zeros(n,1)
  f(x) = ([ sum((x-0.5).^2+1)
            sum(cos(x))
            sum(sin(x))],
          0)
  pareto, population = Fresa.solve(f, x, a, b)

  println("Pareto front:")
  println(pareto)

  using PyPlot
  PyPlot.plot3D(pareto[n+1,:], pareto[n+2,:], pareto[n+3,:], "ro")
  PyPlot.savefig("x.pdf")
#+end_src 
** pareto test
#+name: testpareto
#+begin_src julia :tangle testpareto.jl
  using Fresa
  a = zeros(2,1)
  b = ones(2,1)
  x = rand(2,1)
  f(x) = ( [sin(x[1]-x[2]); cos(x[1]+x[2])], 0)
  z, g = f(x)
  pop = [x; z; g]
  for i=1:9
      x = rand(2,1)
      z, g = f(x)
      pop = hcat(pop,[x; z; g])
  end
  Fresa.setbounds(a,b)
  p = Fresa.pareto(pop)
  println("Population is $pop")
  println("Pareto set is $p")
#+end_src 
** simple objective function
This test uses a simple quadratic objective function, defined within.  All points are feasible within the domain defined by the lower and upper bounds.  All /Fresa/ settings are the defaults.
#+name: testsimple
#+begin_src julia :tangle testsimple.jl
  using Fresa
  x0 = 0.5*ones(2,1)
  a = zeros(2,1)
  b = 10*ones(2,1)
  f(x) = ((x[1]-3)^2+(x[2]-5)^2+8, 0)
  bestx, bestz, bestg, pop = Fresa.solve(f, x0, a, b)
  println("Population at end: $pop")
  println("Best solution is f($bestx)=$bestz with g=$bestg")
#+end_src 
* Recent change history
#+name: changehistoryshellblock
#+begin_src shell :exports results :results output
  hg log --template "{date|shortdate} {desc|firstline}\n" --limit 10
#+end_src
* settings                                                    :noexport:
** org startup on file visit
#+name: startup
#+begin_src emacs-lisp :results none
  (setq-local htmlize-output-type 'inline-css)
#+end_src
** emacs local variables

# Local Variables:
# eval: (esf/execute-startup-block)
# time-stamp-line-limit: 1000
# time-stamp-format: "%04y.%02m.%02d %02H:%02M:%02S"
# time-stamp-active: t
# time-stamp-start: "version = \""
# time-stamp-end: "\""
# End:

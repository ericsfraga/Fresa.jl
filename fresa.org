#+INCLUDE:   /home/ucecesf/hg/homepages/level-0.org
#+title: Fresa, a plant propagation algorithm
#+options: num:nil ^:nil toc:nil tex:imagemagick

| *Author*        | {{{author}}} ({{{email}}})                   |
| *Last revision* | {{{modification-time(%Y-%m-%d %H:%M:%S,t)}}} |

#+toc: headlines 1

* Overview and introduction
/Fresa/ is an implementation of a /plant propagation algorithm/ in [[http://www.julialang.org/][Julia]] programming language.  Our original version was called [[file:strawberry.org][Strawberry]], written in Octave (and usable in MATLAB).  Please see the [[file:strawberry.org][documentation]] of Strawberry for a longer description of the history of these codes, the conditions on which you may use these codes and which articles to cite.

This document has been written using [[http://orgmode.org/][org mode]] in the [[https://www.gnu.org/software/emacs/][Emacs]] text editor.  Org allows for /literate programming/ and uses /tangling/ to generate the actual source files for the code.  The code, tangled from this file, can be found here: call_distribution().

All code (either version) is copyright Â© 2016, Eric S Fraga, all rights reserved.  Permission is given to use this code for evaluation purposes. The code is made available with no warranty or guarantee of any kind.  Use at own risk.  

Please let [[mailto:e.fraga@ucl.ac.uk?subject=The%20Strawberry%20code][the author know]] if you download the code.  Further, if either /Fresa/ or /Strawberry/ codes are sed, please do let the authors know and the [[file:strawberry.org][publications]] must be cited in any research papers written.  Feedback, including bug reports, is most welcome.

In the following code, we assume column vectors for decision variables and objectives.  The convention on constraint violation is 1 meaning yes, i.e. infeasible solution, and 0 means no violation of the constraints.

** Upload to web site                                        :noexport:
#+begin_src shell :results none :exports none
  scp -r fresa.org fresa.html Fresa.jl ltximg socrates.ucl.ac.uk:html.pub
#+end_src
** Code for creating a distribution                          :noexport:
#+name: distribution
#+begin_src shell :results output raw :exports results
  echo [[file:./Fresa.jl][Fresa.jl]]
#+end_src 

#+results: distribution
[[file:./fresa.jl][fresa.jl]]

* Version information

Major version log:

- November 2016 :: first [[http://www.julialang.org/][Julia]] plant propagation algorithm implementation.
* TODO [0/0] improvements or bugs                            :noexport:
* Fresa
:PROPERTIES:
:header-args: :tangle "Fresa.jl"
:END:
#+toc: headlines 2 local
** start of module
#+name: modulestart
#+begin_src julia
  module Fresa

  version = "2016.11.18 09:02:34"
  function __init__()
      println("Fresa PPA $version")
  end
#+end_src
** variables
#+name: variables
#+begin_src julia
  a = 0                           # lower bounds
  b = 1                           # upper bounds
  m = 1                           # objective functions
  n = 1                           # number of decision variables
  npruned = 0
  nsimilar = 0
  ns = 100                        # stopping criterion
  nrmax = 5                       # number of runners
  npop = 10                       # population size
  ngen = 100                      # stopping criterion
  output = 5                      # how often to output
  population_strategy = 4         # new population definition
#+end_src 
** fitness
#+name: fitness
#+begin_src julia
  function fitness(pop)
      k, l = size(pop)
      global m = k-n-1
      println(": $m objective functions with $l members in population")
      if 1 == m
          s = sortperm(pop[n+1,:])
          zmin = pop[n+1,s[1]]
          zmax = pop[n+1,s[length(s)]]
          println(": objective function values in [$zmin,$zmax]")
          f = tanh((zmax - pop[n+1,:]) / (zmax - zmin) - 0.5)+0.5
          println("Fitness $f")
      else
          error("Fresa not imlemented for multi-objective optimisation, nz=$M, yet.")
      end
      f
  end
#+end_src 
** neighbour -- default for real valued decision vectors
#+name: neighbour
#+begin_src julia
  function neighbour(x,f)
      nx = x .+ (1-f) * 2(rand(n,1)-0.5) .* (b-a)
      nx[nx.<a] = a[nx.<a];
      nx[nx.>b] = b[nx.>b];
      return nx
  end
#+end_src 
** set bounds -- for real valued decision vectors
Mostly for testing as bounds will form part of the main method call.
#+name: setbounds
#+begin_src julia
  function setbounds(lower,upper)
      global a = lower;
      global b = upper;
      global n = length(lower);
      println("Size of problem: $n")
  end
#+end_src
** solve -- use the PPA to solve the optimisation problem
#+name: solve
#+begin_src julia
  function solve(f,x0,a,b)
      setbounds(a,b)
      z, g = f(x0)
      println(": f($x0) = $z with constraint $g")
      m = length(z)
      println(": there are $m objective functions.")
      pop = [x0;z;g]
      for gen in 1:ngen
          println(": generation $gen")
          f = fitness(pop)
          for i in 1:max(length(pop),ngen)
              s = select(pop,f)
              if 1 == i
                  newpop = pop[s]
              else
                  newpop = hcat(newpop,pop[s])
              end
              nr = ceil(f[s]*nrmax*rand(1))
              for r in 1:nr
                  x = neighbour(pop[s][1:n],f[s])
                  z, g = f(x)
              end
          end
      end
      pop
  end
#+end_src 
** module end
#+name: moduleend
#+begin_src julia
  end
#+end_src
* tests
#+toc: headlines 2 local
** neighbour
#+name: testneighbour
#+begin_src julia :tangle testneighbour.jl
  using Fresa
  a = -5*ones(5,1)
  b = 5*ones(5,1)
  x = a + (b-a) .* rand(5,1)
  println("$x")
  Fresa.setbounds(a,b)
  for i in 1:10
      print("$i: ")
      n = Fresa.neighbour(x,0.9)
      println("$n")
  end
#+end_src
** simple objective function
This test uses a simple quadratic objective function, defined inline in the invocation of the ~solve~ method.  All points are feasible within the domain defined by the lower and upper bounds.  All /Fresa/ settings are the defaults.
#+name: testsimple
#+begin_src julia :tangle testsimple.jl
  using Fresa
  x0 = 0.5*ones(2,1)
  a = zeros(2,1)
  b = 10*ones(2,1)
  Fresa.setbounds(a,b)
  f(x) = ((x[1]-3)^2+(x[2]-5)^2+8, 0)
  z, g = f(x0)
  pop = [x0;z;g]
  for i in 1:5
      x = Fresa.neighbour(x0,0.5)
      z, g = f(x)
      pop = hcat(pop, [x;z;g])
      npop = size(pop)
      l = length(pop)
      println("Population size $npop with length $l")
  end
  println("Population $pop[3,:]")
  Fresa.fitness(pop)
  #Fresa.solve(f, x0, a, b)
#+end_src 
* Recent change history
#+name: changehistoryshellblock
#+begin_src shell :exports results :results output
  hg log --template "{date|shortdate} {desc|firstline}\n" --limit 10
#+end_src
* settings                                                    :noexport:
** org startup on file visit
#+name: startup
#+begin_src emacs-lisp :results none
  (setq-local htmlize-output-type 'inline-css)
#+end_src
** emacs local variables

# Local Variables:
# eval: (esf/execute-startup-block)
# time-stamp-line-limit: 1000
# time-stamp-format: "%04y.%02m.%02d %02H:%02M:%02S"
# time-stamp-active: t
# time-stamp-start: "version = \""
# time-stamp-end: "\""
# End:

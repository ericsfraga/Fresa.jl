#+INCLUDE:   /home/ucecesf/hg/homepages/level-0.org
#+title: Strawberry plant propagation algorithm
#+options: num:t ^:nil toc:nil tex:imagemagick

| *Author*        | {{{author}}} ({{{email}}})                   |
| *Last revision* | {{{modification-time(%Y-%m-%d %H:%M:%S,t)}}} |

#+toc: headlines 1

* Overview and introduction
Below is the code I have written to implement a /plant propagation algorithm/.  It is based on the algorithm Professor Abdellah Salhi and I developed from his original insight into the propagation of strawberry plants.  The basis of the code in this particular repository is the code used for the results presented in a paper on the modelling of energy systems for domestic dwellings ([[http://dx.doi.org/10.1260/1748-3018.9.1.13][Fraga et al., 2015]]) and in a paper on the control of a dynamic fermentation process ([[http://dx.doi.org/10.1016/j.compchemeng.2017.10.019][Rodman et al., 2018]]).  This code was in turn based on the code used for the original paper ([[https://www.researchgate.net/publication/252321319_Nature-Inspired_Optimisation_Approaches_and_the_New_Plant_Propagation_Algorithm][Salhi & Fraga, 2011]]).  The multi-objective ranking method for fitness evaluation has been described in an up-coming publication ([[http://www.springer.com/gb/book/9783319299730][Fraga & Amusat, 2016]]).

An implementation of the plant propagation algorithm in the [[http://julialang.org/][Julia programming language]], known as [[file:fresa.org][Fresa]], is now available and under further development.  The advantage of this new implementation is the use of Julia.  Julia is a new language for scientific computation which has many key properties including abstract data and dynamic types, multiple dispatch, parallel computing and /just-in-time/ compilation of code for efficiency.

The /Strawberry/ algorithm has been implemented in the [[http://www.gnu.org/software/octave/][Octave]] programming language.  A MATLAB compatible (untested) version, automagically generated from the Octave code, is made available from a link below but it should be noted that the author prefers to use open source software.  The Octave version is embedded in the [[http:strawberry.org][the original ~org~ document]] used to generate this web page.  This document has been written using [[http://orgmode.org/][org mode]] in the [[https://www.gnu.org/software/emacs/][Emacs]] text editor.  Org allows for /literate programming/ and uses /tangling/ to generate the actual source files for the code.  The code, suitably manipulated to be compatible with MATLAB, +can be found here+: call_distribution().

All code (either version) is copyright © 2017, Eric S Fraga, all rights reserved.  Permission is given to use this code for evaluation purposes. The code is made available with no warranty or guarantee of any kind.  Use at own risk.  The code from the above link includes some supplementary functions are required for the /Strawberry/ method (utility functions, multi-objective genetic algorithm (MOGA), and multi-objective steepest descent (MOSD)).

Please let [[mailto:e.fraga@ucl.ac.uk?subject=The%20Strawberry%20code][the author know]] if you download the code.  Further, if the /Strawberry/ code is used, please do let the authors know and the above publications must be cited in any research papers written.  Feedback, including bug reports for either Octave or MATLAB distribution, is most welcome.

In the following code, we assume column vectors for decision variables and objectives.  The convention on constraint violation a positive value for infeasible solutions and non-positive for feasible.

** Upload to web site                                        :noexport:
#+name: upload
#+begin_src shell :results none :exports none
  scp -r strawberry.org strawberry.html strawberry_test3.png ltximg socrates.ucl.ac.uk:html.pub
#+end_src
** Code for converting from octave to MATLAB                 :noexport:
#+name: distribution
#+begin_src shell :results output raw :exports results
  dist="strawberry-$(date +%Y%m%d)"
  mkdir ${dist}
  for mfile in $(find ${HOME}/synced/share/octave/researchcodes/ -name '*.m') \
                   $(find ${HOME}/synced/share/octave/strawberry/ -name '*.m')
  do
      base=$(basename ${mfile} .m)
      cat ${mfile} | sed -e 's/#/%/g' \
                         -e 's/endfunction/end/' \
                         -e 's/endfor/end/' \
                         -e 's/endif/end/' \
                         -e 's/endswitch/end/' \
                         -e 's/end_try_catch/end/' \
                         -e 's/endwhile/end/' \
                         -e 's/ printf/ fprintf/' \
                         -e 's/^printf/ fprintf/' \
                         > ${dist}/${base}.m
  done
  zip -r ${dist}.zip ${dist} > /dev/null 2>&1
  rm -r ${dist}
  scp ${dist}.zip socrates.ucl.ac.uk:html.pub/ >/dev/null 2>&1
  echo "[[file:./${dist}.zip][${dist}.zip]]"
#+end_src 

#+results: distribution
[[file:./strawberry-20171121.zip][strawberry-20171121.zip]]

* Version information

Major version log:

- November 2016 :: change of interface to Strawberry: the objective function must now return not only the objective function values (first entry in return list) but also the feasibility (measure of constraint violation) of the point in the search space (as second entry).
- July 2016 :: multi-objective version extended to work for any number of criteria instead of just 2.
- October 2015 :: started work on a MI-Strawberry version, hopefully as upwards compatible as possible.
- September 2015 :: implemented a rank based fitness, used to prepare results in [[http://www.springer.com/gb/book/9783319299730][the paper on understanding the impacts of constraints]].  There is now a choice of fitness functions as the old, Pareto based, fitness function is still available (cf. Deb (2000) for an example).
* TODO [4/14] improvements or bugs                            :noexport:
- [ ] define a GAMS interface; for multi-objective problem, solve the same model for each criterion individually to generate the objective function value for each design point. 
- [ ] Note taken at MCDA meeting in Padova
  implement a relaxed dominance definition in Strawberry to better explore the set of non-dominated points.  \epsilon would be based on range of values expected or range actually existing in a population. the identification of an \epsilon based non-dominated set will be non-deterministic or not unique.  Does this matter?
- [ ] keep an elite set (best of set ∪ best in population) which is not involved in selection but which is presented at the end.  This is to avoid non-dominated solutions that are lost along the way when dealing with multi-objective problems.
- [ ] include an evolution strategy as part of a genome for a GA 
  - where the strategy is a combination of specific crossover and mutation operators.
  - motivated by talk in session of META'2016 that I chaired on recent trends.
  - could we use a strategy for distance of neighbours within Strawberry as part of the solution itself as well?
- [ ] Hamming code for permutation vector distance and direction definitions.  This came about from discussions at META'2016 from a talk which used a GA to manipulate permutations.  Could consider this as an alternative for a distance for the [[file:~/s/research/others/abdellah.salhi/c1p/c1p.org][C1P problem]].
- [ ] handling /uncertainty/ in strawberry with either probability distribution functions (*pdf*) or intervals.  The latter should be easier and possibly sufficient.
- [ ] should propagate each individual only once, i.e. select (whether with tournament selection or otherwise) an individual only once so remove it from subsequent selection steps
- [ ] should only evaluate new points, whether in parallel or not
- [ ] consider only accepting solutions if they improve on the parent, possibly using a form of /Metropolis-Hastings/ acceptance rule as used in simulated annealing.
- [ ] consider resource availability.  I wrote this after the EGH 2015 meeting and I am not sure exactly what I meant but it could be that we shouldn't allow too many solutions in the same place so maybe some form of diversity control?  not sure.
- [X] *mixed-integer* Strawberry:
  - could we get away with not change anything in the main code but assume that the user passes a function which maps a given solution vector /x/ to a new one, taking care of rounding, e.g. for integer variables?
- [X] need to handle the case of the Pareto set becoming ever larger, potentially infinite in size.  We should prune the set somehow.
- [X] consider killing plants off after a certain number of generations, but keeping an overall /best/ solution record to ensure we don't lose the best solution found overall.  In terms of multi-objective optimisation, this may mean keeping an elite set of non-dominated solutions.
- [X] can we make the code available externally, e.g. on a web site?  If so, we need to bring in the MOGA codes into this code base.  This may not be a bad idea in any case but it does limit code re-use.
* Strawberry -- main entry point
:PROPERTIES:
:header-args: :tangle "strawberry.m"
:END:
#+toc: headlines 1 local
** overview
The algorithm is *evolutionary*, iterating over a number of generations.  In each generation, the solutions are ranked according to the objective function values.  In each generation, a number are selected for *propagation*.  Each solution can propagate itself a number of times and a certain distance with both aspects being a function of the solution's fitness.  The best solutions propagate more but for shorter distances to exploit the quality of the solution, i.e. a /local/ search; the not so good solutions propagate less but further to explore the domain, i.e. a /global/ search.

A hybrid procedure using a multi-objective steepest descent method, ~MOSD~, is optional.

All of the following ~src~ blocks will be *tangled* to the same [[file:strawberry.m][strawberry.m]] file.

The default /distance/ and /neighbour/ functions are suitable for using Strawberry to solve this problem:
\begin{align*}
  && \min_{x\in\cal{D}} z & = f(x) \\
  \mbox{where} && \cal{D} & \equiv [a,b]^n \subset {\cal{R}}^{n} \\
  \mbox{subject to} &&  g(x) & \le 0
\end{align*} 
** function definition
#+begin_src octave :noweb yes :tangle strawberry.m
  function [x z nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output)
#+end_src
*** Arguments
The function has the following arguments:
- x0 :: initial member of the population of solutions
- a :: lower bounds on all variables
- b :: upper bounds for all variables
- f :: handle for the objective function which has signature
     : [z g] = f(x)
     where ~z~ is a vector of objective function values and ~g~ indicates whether a solution is feasible (~g <= 0)~ or infeasible (~g > 0~).  The actual value of ~g~ for infeasible solutions is used to rank solutions.  Negative values of ~g~ are not used at all.  If your objective function is unconstrained, simply ensure that ~0~ is returned as the second entry in the return list.
- ngen :: one of the stopping criteria: maximum number of generations of plant propagation to allow
- npop :: the base number in the population.  The actual number will be larger, depending on the value of ~nrmax~.  ~npop~ decides how many plants actually propagate but the number of new solutions depends on the fitness of those chosen to propagate and the maximum number of runners allowed, ~nrmax~.
- nrmax :: the maximum number of runners to create for any solution if chosen to propagate.
- ns :: a stopping criterion based on the number of consecutive generations for which no new /best/ solution is found.
- population_strategy :: The strategy to use for creating a new population after the propagation of chosen solutions:
     The strategy to use for creating a new population after the propagation of chosen solutions:
  1. newly created solutions (propagated) alone
  2. newly created solutions along with those selected for propagation
  3. the /best/ from the current population, where /best/ will be a single solution for single objective optimisation and a set of /non-dominated/ solutions for multi-objective optimisation.
  4. union of the /best/, the /selected/ and the /new/ solutions.
- output :: An integer indicating how often to output statistics about the search.

In all of the above, vectors (solutions and objective function values for multi-objective optimisation) are column vectors.

Only the first four arguments, ~x0~, ~a~, ~b~ and ~f~, are required.  The rest are optional and default to the following values:
|---------------------+---------|
| ngen                |    1000 |
| npop                |     100 |
| nrmax               |       5 |
| ns                  |     100 |
| population_strategy |       4 |
| output              | ngen/50 |
|---------------------+---------|

*** Return values
The function returns the best point found, ~x~, with associated objective function values, ~z~.  It also returns information on the search:
- ~nf~ :: number of objective function evaluations.
- ~ninf~ :: number of infeasible function evaluations.
- ~bestgen~ :: the generation in which the best solution, ~<x,z>~, was obtained.
For multi-objective optimisation, ~x~ and ~z~ will be an approximation to the Pareto front defined by a set of /non-dominated/ points and associated objective function values.
** initialisation
#+begin_src octave :noweb yes :tangle strawberry.m
  global esfdebug
  global mosd_numberimproved
  global npruned
  global nsimilar
  global strawberry_archive
  global strawberry_fitness_method
  global strawberry_diversity_tolerance
  global strawberry_lower strawberry_upper
  global strawberry_neighbourfn 
  global strawberry_output_population
  mosd_numberimproved = 0;
  npruned = 0;
  nsimilar = 0;
  stderr = 2;                     # for MATLAB compatibility
  warning ('error', 'Octave:broadcast');
  ## process arguments
  if nargin<9, population_strategy = 4; end # population selection strategy
  if nargin<8, ns = 100; end    # number of stable generations
  if nargin<7, nrmax = 5; end   # number of runners
  if nargin<6, npop = 100; end  # population size
  if nargin<5, ngen = 1000; end # number of generations
  if nargin<4
    disp('Error: need at least 4 arguments to Strawberry method: x0, a, b & f.')
    return
  end
  strawberry_lower = a;
  strawberry_upper = b;
  if nargin<10, 
    output = ngen/50;
  end             # how often to output status of population
  ## process global variables
  if isempty (strawberry_archive)
    strawberry_archive = 0;
  endif
  if strawberry_archive > 0
    printf(': pareto solutions are archived\n');
  endif
  if isempty (strawberry_fitness_method)
    strawberry_fitness_method = 1;  #choose MOGA fitness for now
  end
  strawberry_diversity_tolerance = norm(b-a) / 1000;

  ## determine the number of processors to use in parallel.  If the
  ## variable has not been set, we use the system function to determine
  ## how many processors there are
  global strawberry_numberofprocessors
  if isempty(strawberry_numberofprocessors)
    strawberry_numberofprocessors = 1; # not currently working for np>1, nproc();
  endif
  if strawberry_numberofprocessors > 1
    printf (': using %d processors for parallel processing.\n', strawberry_numberofprocessors);
    starttime = time;           # use wall clock time instead of CPU time
  else
    printf (': not using any parallel processing on a single processor system.\n');
    starttime = cputime;
  endif
  if isempty(strawberry_output_population)
    strawberry_output_population = 0
  endif
  strawberry_initialise
  printf(': ngen=%d npop=%d nrmax=%d ns=%d population strategy=%d and tolerance=%f fitness method=%d\n', ngen, npop, nrmax, ns, population_strategy, strawberry_diversity_tolerance, strawberry_fitness_method)

#+end_src
** constrained problem?
Determine whether the objective function also has information on feasibility.
#+begin_src octave
  constrained = 1;
  try
    [z g] = f(x0);
  catch err
    printf('Error identifier is %s\n', err.identifier);
    printf('Error message is %s\n', err.message);
    printf('\nThis could be due to the change in Strawberry that\n')
    printf('now requires the objective function to return a\n')
    printf('feasibility indication as well as the objective function\n')
    printf('value(s).\n\n')
    if (strcmp (err.identifier, 'Octave:undefined-function') || strcmp(err.identifier,'MATLAB:UndefinedFunction'))
      printf(': objective function is unconstrained.\n')
      constrained = 0;
    else
      ## not an error we expected to pass this on
      rethrow(err);
    endif
  end_try_catch
  if constrained
       printf(': objective function is constrained.\n');
  endif
#+end_src
** initial population
#+begin_src octave :noweb yes :tangle strawberry.m
  [phi, nx, nz, nf, ninf] = strawberry_newpopulation (x0,npop,f,constrained);
  pop = strawberry_sort (phi,nx,nz);
  gen = 0;
  best = [];                      #will be defined after fitness evaluation
  bestgen = gen;
  nfunctionevaluations = npop; # initial population size

  if output > 0
    printf('In the following table, $n_f$ is number of feasible points,\n')
    printf('$n_i$ for infeasible, $n_p$ number in Pareto set\n');
    printf('$c$ best constraint value and $g_b$ best generation.\n');
    printf('| %9s |', 'gen')
    if nz > 1
      for i=1:nz, printf('  $z_{%02d}$ |', i); endfor
      if constrained; printf(' %9s |', 'c'); endif
    else
      index = nx;
      if nx > 4
        index = 4;
      endif
      for i=1:index; printf(' %6sx%02d |', '', i); endfor
      for i=1:nz; printf(' %6sy%02d |', '', i); endfor
      if constrained; printf(' %9s |', 'c'); endif
    endif
    printf(' %5s | %5s |', '$n_f$', '$n_i$')
    if nz > 1
      printf(' %5s |', '$n_p$')
    else
      printf(' %5s |', '$g_b$')
    endif
    printf('\n');
    printf('|-\n');
  endif
#+end_src
** iterate
#+toc: headlines 1 local
#+begin_src octave :noweb yes :tangle strawberry.m
  while gen < ngen && (nz > 1 || gen < bestgen+ns)
    gen = gen + 1;
#+end_src
*** prune similar solutions to encouraged diversity
Remove duplicate members as they contribute nothing.
#+begin_src octave :noweb yes :tangle strawberry.m
  ## printf('npruned=%d nx=%d nz=%d\n', npruned, nx, nz)
  pop = strawberry_prune (pop, nx, nz);
  ## printf('npruned=%d nx=%d nz=%d\n', npruned, nx, nz)
#+end_src
*** rank solutions
The fitness method is used to find the best members of the population and assign each one a ranking N \in (0,1) with higher values better than lower values.  

In the multi-objective case, the pareto front is combined with the elite set, a new pareto front is identified and duplicates are removed.  The elite set does not get involved in the selection and propagation.
#+begin_src octave :noweb yes :tangle strawberry.m
  ## evaluate the fitness of the population.  For multi-objective problems,
  ## this has the side effect of returning the pareto front 
  [N pareto] = strawberry_fitness (pop,nx,nz,size(pop,2));
  ## populationstatistics('pareto',pareto,nx,nz);
  ## keep track of best.  For multi-objective problems, this means keeping the pareto set
  debugprint(1, 'best', best)
  debugprint(1, 'pareto', pareto)
  debugprint(1, 'pop(1)', pop(:,1))
  debugprint(1, 'nx, nz', [nx, nz])
  if nz < 2 ...
     && (isempty(best) ...
         || length(best) < 1 ...
         || (pareto(nx+1) < best(nx+1) ...
             && norm(abs(best(1:nx)-pareto(1:nx))) > 1e-6))
    best = pareto;
    bestgen = gen;
    ## zzz = zfit (best (1:nx))
    if ~output
      printf('\n... new best solution at generation %d, z(1)=%g x=', gen, best(nx+1));
      printf('%g ', best(1:nx));
      printf('\n');
    endif
  elseif nz>1
    ## update the best to be the set of non-dominated points from the union
    ## of the old best and the current population but only include old
    ## best if we wish to archive solutions
    if strawberry_archive > 0
      if isempty(best) || length(best) <= 1
        best = pareto;
      else
        union = [best, pareto];
        if length(union) < nx+nz+1
          best = [];
        else
          best = strawberry_prune(union(:,findpareto(union(nx+1:nx+nz,:))),nx,nz);
        endif
      endif
    else
      best = pareto;
    endif
    debugprint (1, 'size of pareto: ', length(best))
  endif
#+end_src
*** periodic output
There are two types of periodic output.
**** population statistics to console
The first, controlled by the ~output~ argument to the function, is a single line summary of the status of the current population.  This defaults to outputting a total of 50 lines over the full evolution.
#+name: outputstatistics
#+begin_src octave :noweb yes :tangle strawberry.m
  ## populationstatistics('whole',pop,nx,nz);
  ## populationstatistics('best',best,nx,nz);
  if output > 0 && (0 == mod(gen,output) || 1 == gen)
    if strawberry_numberofprocessors > 1
      dtime = time-starttime;
    else
      dtime = cputime-starttime;
    endif
    fprintf(stderr, '\r');
    printf('| %9d |', gen);
    nfeas = sum(pop(end,:)<=0.0);
    ninfeas = sum(pop(end,:)>0);
    if nz > 1
      if ~ isempty(best) && length(best)>1
        ## printf('Size of best: %d %d\n',size(best))
        printf (' %9.3g |', min(best(nx+1:nx+nz,:),[],2))
        if constrained; printf(' %9.3g |', min(best(nx+nz+1,:))); endif
      else
        printf(' %9.3g |', zeros(nz+constrained,1));
      endif
      printf(' %5d | %5d | %5d |', nfeas, ninfeas, size(best,2));
    else
      if nx > 5
        indices = [1:4 nx+nz];
      else
        indices = 1:nx+nz;
      endif
      printf (' %9.3g |', best(indices))
      if constrained; printf(' %9.3g |', best(nx+nz+1)); endif
      printf(' %5d | %5d | %5d |', nfeas, ninfeas, bestgen);
    endif
    printf('  \n');
  else
    if nz > 1
      ## [fitness pareto] = moga_fitness (pop(1:nx,:), pop(nx+1:nx+nz,:));
      ## fprintf(stderr, '\r%30s %7d %3d/%4d %9.3g %9.3g %9.3g %9.3g', '', gen, size(best,2), length(pop), best(nx+1:nx+nz,1), best(nx+1:nx+nz,end))
      fprintf(stderr, '\r%30s %7d %3d/%4d ', '', gen, size(best,2), length(pop))
    else
      if constrained
        fprintf(stderr, '\r%30s %9d [%9d] %5d %13.6e %13.6e ', '', gen, bestgen, length(pop), best(nx+nz), best(nx+nz+1));
      else
        fprintf(stderr, '\r%30s %9d [%9d] %5d %8d %13.6e ', '', '', gen, bestgen, length(pop), nfunctionevaluations, best(nx+nz));
      endif
    endif
  endif

  debugprint (1,'strawberry: fitness', N);
  actualnpop = size(pop,2);
  if actualnpop < size (pop,2)
    printf('Ummmm size of population %d is less than expected (%d)\n', size(1,pop), npop);
  endif
#+end_src
**** pareto set to file
The second is the output of the full population to an automatically named file (based on time stamp and generation number).  The default is to not generate this output.  This output is controlled by setting the global variable ~strawberry_output_population~ which should be set to a positive number that specifies which generations to output (modulo == 0).

This output is only available for multi-objective problems and a file will be saved only if there is at least one feasible member in the population.
#+name: outputpopulation
#+begin_src octave
  if strawberry_output_population > 0 ...
     && 0 == mod(gen,strawberry_output_population)
      filename = sprintf('%s-%s-%06d.data', 'strawberry-population', ...
                         strftime('%Y%m%d-%H:%M:%S', localtime(time())), ...
                         gen);
      [sorted sortindices] = sort(best(nx+1,:));
      poptrans = best(:,sortindices)';
      save('-text',filename,'poptrans');
  endif
#+end_src 
*** select and propagate
#+begin_src octave :noweb yes :tangle strawberry.m
  ## generate all the new points and then evaluate them in parallel
  n = 1;
  newpop = [];
  selected = [];
  for p=1:npop                # we pick up to NPOP members to propagate
    s = strawberry_select (N);
    debugprint(2,'selected index', s)
    if s > 0
      selected(:,p) = pop(:,s);   # selected members remain for next generation; others die off
      debugprint(3, 'selected fitness and point: ', [N(s), pop(:,s)']);
      nr = strawberry_runners (N(s),nrmax); # number of runners
      debugprint(2,': number of runners', nr)
      for r=1:nr
        newpop{n} = strawberry_neighbourfn(pop(1:nx,s), N(s));
        debugprint(2, ': added new member to population: ', newpop{n})
        n = n + 1;
        ## endif
      endfor
      ## set fitness so this member is not selected again
      N(s) = -1;
    endif
  endfor
  debugprint(1,'Size of selected set: ', size(selected))
  debugprint(1,'Size of newpop: ', size(newpop))
  ## evaluate these in parallel using an appropriate number of processors
  ##parf = @(x) if length(x)>nx, x', else [x, f(x), 0]', endif
  ##phi = parcellfun (strawberry_numberofprocessors, parf, newpop)';

  if strawberry_numberofprocessors > 1
    if constrained
      phi = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); g(x)], newpop, 'VerboseLevel', 0);
    else
      phi = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); 0], newpop, 'VerboseLevel', 0);
    endif
  else                            #sequential evaluation
    n = length(newpop);
    x = newpop{1};
    if constrained
      [y g] = f(x);
    else
      y = f(x);
      g = 0;
    endif
    phi = zeros(length(x)+length(y)+1,n);
    phi(:,1) = [x;y;g];
    for i=2:n
      x = newpop{i};
      nf = nf + 1;
      if constrained
        [y g] = f(x);
        if g > 0
          ninf = ninf + 1;
        endif
      else
        y = f(x);
        g = 0;
      endif
      phi(:,i) = [x;y;g];
    endfor
  endif
  nfunctionevaluations = nfunctionevaluations + length(phi);
  debugprint (1, ': phi before removal of infeasible solutions', phi)
  ntotal = size(phi,2);
#+end_src
*** COMMENT apply local search
#+begin_src octave :noweb yes :tangle strawberry.m
  ## try to improve each of the new solutions using a local search
  ## procedure, or maybe only a single step or so of that procedure.
  ## for i=1:length(phi)
  ##   sdpop{i} = phi(1:nx,i);
  ## endfor
  ## function point = mosderrorhandler (s, f, x, a, b)
  ##   printf('Error %d: index %d message=%s\n: ', s.identifier, s.index, s.message)
  ## endfunction
  ## improvedset = parcellfun (strawberry_numberofprocessors, @(x) [mosd(f,x,a,b)], sdpop, 'ErrorHandler', @mosderrorhandler);

  ## as we cannot figure out how to get parcellfun to do what we want, we use sequential processing here for the time being
  sdphi = zeros(size(phi));
  for i=1:size(phi,2)
    sdphi(:,i) = mosd (f, phi(1:nx,i), a, b);
  endfor
  ## combine the two and hope diversity check removes duplicates
  phi = [phi, sdphi];
#+end_src
*** create new population
#+begin_src octave :noweb yes :tangle strawberry.m
  ## sort the population, which is composed of the original NPOP
  ## best plus those created in this loop, using the fitness for
  ## sorting.
  ## we have three sets of solutions that we can combine to create a
  ## new population:
  ## 1. the best overall so far
  ## 2. the members selected from the previous generation for propagation
  ## 3. and the new propagated solutions
  ## there are therefore 3! combinations although we always should
  ## include the new solutions so really have 4 different options:
  ## new alone, new with best, new with selected and new with
  ## selected and best.

  ## fprintf(stderr, 'size best=%d selected=%d phi=%d\n', size(best,2), size(selected,2), size(phi,2));
  ## cater for when best array is empty
  ps = population_strategy;
  if ps > 2 && length(best) > (npop/2)
    ## do not do elitism if pareto set too large; kludge!
    ps = ps - 2;
  endif
  switch (ps)
    case 1               # new members alone
      pop = phi;
    case 2               # new with selected
      pop = [selected, phi];
    case 3               # new with best
      pop = [best, phi];
    case 4               # new with best and selected
      pop = [best, selected, phi];
    otherwise
      printf('Error: population strategy %d not recognised.', population_strategy)
  endswitch
#+end_src
** end loop and finish function
#+begin_src octave :noweb yes :tangle strawberry.m
  endwhile
  if gen < ngen
    printf('\n: strawberry terminating condition satisfied due to lack of improvement at gen=%d\n', gen);
  endif
  if output
    printf('\n: strawberry at end, nf=%d ninf=%d best solution:\n', nf, ninf)
    disp(best');
  endif
  ## ensure the best solution is returned
  pop = [best, pop];
  x = pop(1:nx,:);
  z = pop(nx+1:end,:);
  if strawberry_numberofprocessors > 1
    endtime = time;            # wall clock time
  else
    endtime = cputime;
  endif
  printf('\n: strawberry method elapsed time: %.1f with %d functions evaluated and %d solutions pruned with %d similar.\n', ...
         endtime-starttime, nf, npruned, nsimilar)
  printf('MOSD improvements: %d\n', mosd_numberimproved);
  endfunction
#+end_src
* Support functions
#+toc: headlines 1 local

** distance -- default implementation
The distance method determines how far to send a runner.  The first argument is the fitness, \(f \in [0,1]\), and the second is the dimension of the problem, \(n>0\), i.e. the number of decision variables.  

The basic premise is that the fitter the solution, the less far runners are sent as there is plenty of /food/ in this local neighbourhood.  A less fit point will send runners further.
#+begin_src octave :tangle strawberry_distance.m
  function d = strawberry_distance(f,n)
    d = (1-f) * 2*(rand(n,1)-0.5);
  endfunction
#+end_src
** fitness -- for single and multi-objective functions

The fitness of the members in the population is calculated differently for 1 criterion problems and multi-criteria problems.  The former is based on a scaled value within the range of values for feasible and infeasible solutions separately.

For multi-objective problems, we have a number of options.  We can use the approach we used in [[http://dx.doi.org/10.1080/03052150903074189][MOGA]]  which was based on distance to the Pareto set of non-dominated solutions.  However, this has a problem when the set is large compared with the total population size.  Also, it does not necessarily push towards the endpoints of the Pareto front which is often, in the problems we consider, what we want.

To accomplish the latter, we consider a ranking that takes into account how good each individual objective value is within its own set of values.  If we consider a fitness 1,... for each point for each objective, and then multiply these two ranking values together, this should emphasise the end-points.  The multiplication of vectors of rankings in known as the [[https://en.wikipedia.org/wiki/Hadamard_product_(matrices)][Hadamard]] product.

#+name: fitness
#+begin_src octave :tangle strawberry_fitness.m
  function [fit, best] = strawberry_fitness(p,nx,nz,npop)
    global strawberry_fitness_method
    [n m] = size(p);
    debugprint (1, 'fitness, nx nz m n npop', [nx, nz, m, n, npop])
    if m <= 0
      disp('No solutions in the population');
    endif
    fit = zeros(m,1);
    factor = 1;                # for placement in fitness interval (0,1)
    indexfeasible = p(n,:) <= 0;
    nfeas = sum(indexfeasible);
    indexinfeasible = p(n,:) > 0;
    ninfeas = sum(indexinfeasible);
    if nfeas > 0
      feasiblefit = strawberry_vectorfitness(nz, p(nx+1:nx+nz,indexfeasible));
      ## the ranking of the feasible solutions is possibly adjusted to
      ## fit in only the upper half of the [0,1] interval if there are
      ## infeasible solutions as well.  The latter will have fitness
      ## values in the bottom half of the interval.
      if ninfeas > 0
        factor = 2;
      end
      fit(indexfeasible) = (feasiblefit+factor-1)/factor;
    end
    if ninfeas > 0
      ## squeeze infeasible fitness values into (0,0.5) or (0,1)
      ## depending on factor, i.e. whether there are any feasible
      ## solutions as well or not
      fit(indexinfeasible) = strawberry_vectorfitness(1, p(n,indexinfeasible))/factor;
    end
    if nz < 2
      [bestfit index] = max(fit);
      best = p(:,index);
    else
      ## printf('There are %d feasible solutions when calculating fitness\n',nfeas)
      if nfeas > 0
        allindices = 1:m;
        feasibleindices = allindices(indexfeasible);
        ## printf('feasible population:\n')
        ## disp(p(:,indexfeasible))
        ## printf('and pareto from that population\n')
        ## disp(p(:,feasibleindices(findpareto(p(nx+1:nx+nz,indexfeasible)))))
        best = p(:,feasibleindices(findpareto(p(nx+1:nx+nz,indexfeasible))));
      else
        best = [];
      endif
    endif
  endfunction
#+end_src

#+name: vectorfitness
#+begin_src octave :tangle strawberry_vectorfitness.m
  function fit = strawberry_vectorfitness(m,v)
    ## println("VF: v=$v")
    ## println("  : of size $(size(v))")
    if m == 1                   # single objective 
      l = length(v);
      [sorted indices] = sort(v);
      zmin = v(indices(1));
      zmax = v(indices(l));
      if l == 1 || abs(zmax-zmin) < eps()
        fit = 0.5*ones(1,l);
      else
        ## avoid extreme 0,1 values
        fit = tanh((zmax - v) / (zmax - zmin) - 0.5)+0.5;
      end
    else                  # multi-objective
      [m, l] = size(v);
      rank = ones(m,l); #rank of each solution for each objective function 
      for i=1:m
        [sorted indices] = sort(v(i,:));
        rank(i,indices) = 1:l;
      end
      ## hadamard product of ranks
      fitness = prod(rank);
      ## normalise and reverse meaning (1=best, 0=worst)
      if l == 1
        fit = 0.5;
      else
        ## avoid extreme 0,1 values
        fit = tanh(0.5 - fitness / max(fitness)) + 0.5;
      end
    end
    ## println("VF: fit=$fit")
  end

#+end_src 

** initialise -- default values and version information

#+name: version
#+begin_src octave :tangle strawberry_initialise.m
  function strawberry_initialise
    global strawberry_version
    global strawberry_numberofprocessors
    global strawberry_octave
    global moga_version
    global mosd_version
    if isempty (strawberry_version)
      strawberry_version = '2017.11.23 07:32:07';
      mosd_initialise
      moga_initialise
      printf (': STRAWBERRY %s, main function\n', strawberry_version)
      printf (': using MOSD %s, multi-objective steepest descent method.\n', mosd_version)
      printf (': and MOGA %s, multi-objective genetic algorithm fitness function.\n', moga_version)
      strawberry_octave = exist ('OCTAVE_VERSION', 'builtin') > 0;
      if strawberry_octave
        printf(': running in Octave\n')
        if strawberry_numberofprocessors > 1
          pkg load parallel             #need parcellfun in particular
        endif
      endif
    endif
#+end_src
We define default functions for the key steps in the strawberry algorithm:
- new random solution :: generate a random solution in the search space
- neighbour :: given an existing point in the search space, generate a new solution based on the fitness value (0<f<1 with 1 most fit) given
These functions allow strawberry to be used for more general problems than just nonlinear programming problems.  The default functions, however, are suitable for compact domains defined by bounds in the R^n.
#+begin_src octave :tangle strawberry_initialise.m
  global strawberry_lower
  global strawberry_neighbourfn
  global strawberry_randomsolutionfn
  global strawberry_upper
  if isempty(strawberry_randomsolutionfn)
    strawberry_randomsolutionfn = @strawberry_randomsolution;
    printf (': using default random solution generator function.\n');
    if isempty(strawberry_lower)
      error('Default strawberry method requires definition of strawberry_lower global vector');
    endif
    if isempty(strawberry_upper)
      error('Default strawberry method requires definition of strawberry_upper global vector');
    endif
  endif
  if isempty(strawberry_neighbourfn)
    strawberry_neighbourfn = @strawberry_neighbour;
    printf (': using default neighbouring solution generator function.\n')
  endif
#+end_src
** isdiverse -- identify solutions that differ
We only want to add solutions to the population that are diverse, i.e. significantly different, from those that are already there.  However, the diversity control should not be at the expense of losing better solutions.  The current implementation is not good in this respect and should be used with care as a result.
#+begin_src octave :tangle strawberry_isdiverse.m
  function diverse = strawberry_isdiverse (pop, x)
    global nsimilar
    global strawberry_diversity_tolerance
    i = 0;
    diverse = 1;
    while i < length(pop) && diverse
      diverse = norm(pop{i}-x) > strawberry_diversity_tolerance;
      i = i + 1;
    endwhile
    if ~ diverse, nsimilar = nsimilar + 1; endif
  endfunction
#+end_src
** neighbour -- for compact real valued domains
Given a fitness value and a point in the search space, generate a new point in the space.  The better the fitness, the closer the point should be to the given point.  The basis of the Strawberry algorithm is that fit points generate more points in the local area; less fit points generate fewer new points but further away.  Exploitation versus exploration.

The default implementation uses the fitness to define a distance within the bounds of the variables for each dimension.
#+name: neighbour
#+begin_src octave :tangle strawberry_neighbour.m
  function n = strawberry_neighbour(x,f)
    global strawberry_lower strawberry_upper
    nx = length(x);
    dx = (strawberry_upper-strawberry_lower)/2 .* strawberry_distance (f,nx); # how far to run
    ## fprintf(stderr, 'Selected %d with fitness %g to move %g\n', s, N(s), norm(dx))
    debugprint(3, ': dx', dx(1:nx))
    n = x+dx;
    n(n<strawberry_lower) = strawberry_lower(n<strawberry_lower);        # reset to boundary
    n(n>strawberry_upper) = strawberry_upper(n>strawberry_upper);        # reset to boundary
  endfunction
#+end_src
** newpopulation -- create an initial population
Create a random population, distributed uniformly (hopefully) throughout the domain defined by the lower and upper bounds of the optimisation variables.
#+name: newpopulation
#+begin_src octave :tangle strawberry_newpopulation.m
  function [pop, nx, nz, nf, ninf] = strawberry_newpopulation (x0,npop,f,constrained)
    global strawberry_randomsolutionfn
    global strawberry_numberofprocessors
    nx = length(x0)
    nf = 0;
    ninf = 0;
    pop = [];                     # will be array of x+y values
    n = 0;
    ntries = 0;
    xcell{1} = x0;                        # start with initial guess

    for i=2:npop
      xcell{i} = strawberry_randomsolutionfn();
    endfor
    if strawberry_numberofprocessors > 1
      if constrained
        pop = parcellfun (strawberry_numberofprocessors, ...
                          @(x) [x; f(x); g(x)], xcell, 'VerboseLevel', 0 ...
                         );
      else
        pop = parcellfun (strawberry_numberofprocessors, ...
                          @(x) [x; f(x); 0], xcell, 'VerboseLevel', 0);
      endif
    else                          #sequential operation
      x = xcell{1};
      if constrained
        [z g] = f(x);
      else
        z = f(x);
        g = 0;
      endif
      y = [x; z; g];
      pop = zeros(length(y),npop);
      pop(:,1) = y;
      for i=2:npop
        x = xcell{i};
        nf = nf+1;
        if constrained
          [z g] = f(x);
        else
          z = f(x);
          g = 0;
        endif
        pop(:,i) = [x; z; g];
      endfor
      ## pop = cellfun (@(x) [x; f(x); 0], xcell);
    endif
    mtotal = size(pop,2);
    [n m] = size(pop);
    ninf = ninf + mtotal - m;
    ## each row consists of nx x values, nz y values and a feasibility
    ## indication
    nz = n-nx-1
  endfunction
#+end_src
** populationstatistics -- mostly for debugging
#+name: populationstatistics
#+begin_src octave :tangle populationstatistics.m
  function populationstatistics(s,p,nx,nz)
    [m n] = size(p);
    feasible = p(end,:) <= 0;
    nfeasible = sum(feasible);
    infeasible = p(end,:) >= 0;
    ninfeasible = sum(infeasible);
    printf('Population statistics for %s:\n', s)
    printf(': there are %d members of which %d are feasible.\n', n, nfeasible)
    printf(': min objective function values: ')
    printf('%g ', min(p(nx+1:nx+nz,:),[],2))
    printf('\n');
    if nfeasible > 0
      printf(': constraint values for feasible solutions in [%g,%g]\n', ...
             min(p(end,feasible)), max(p(end,feasible)));
    endif
    if ninfeasible > 0
      printf(': constraint values for infeasible solutions in [%g,%g]\n', ...
             min(p(end,infeasible)), max(p(end,infeasible)));
    endif
  endfunction
#+end_src 
** prune -- remove non-diverse members 
Especially for multi-objective problems, we have a problem with diversity in that the pareto set forms an *elite* set.  If this set has multiple copies of the same solutions, the set can grow quite large and increases the computational effort dramatically with little effect on the quality of the solutions obtained.
#+name: prune
#+begin_src octave :tangle strawberry_prune.m
  function pruned = strawberry_prune (pop, nx, nz)
    global npruned
    global strawberry_diversity_tolerance
    npop = size(pop,2);
    if npop > 0
      pruned = pop(:,1);
      np = 1;                       # size of pruned set
      for i=2:npop
        diverse = 1;
        j = 0;
        while diverse && j < np
          j = j + 1;
          ## diversity based on x values alone
          diverse = norm (pop(1:nx,i)-pruned(1:nx,j)) > strawberry_diversity_tolerance;
          ## printf('div(%d,%d)=%g %d\r', i, j, norm (pop(1:nx,i)-pruned(1:nx,j)), diverse);
        endwhile
        if diverse
          pruned = [pruned, pop(:,i)];
          np = np + 1;            #keep track of how many copied over
        else
          ## prune one or the other.  ideally, we keep the better
          ## one.  If we cannot distinguish (in a multi-objective
          ## sense), we simply keep the one that is already there. 
          npruned = npruned + 1;
          if ~ dominates(pruned(nx+1:nx+nz,j),pop(nx+1:nx+nz,i))
            if dominates(pop(nx+1:nx+nz,i),pruned(nx+1:nx+nz,j))
              ## current solution is better, i.e. dominates, than previous
              ## one so replace
              pruned(:,j) = pop(:,i);
            endif
          endif
        endif
      endfor
    endif
  endfunction
#+end_src
** random solution -- generate a new solution 
By default, this function returns a random solution in a compact hypercube domain in R^n defined by the bounds on the variables.  The default function requires the definition of the lower and upper bounds for the domain.
#+begin_src octave :tangle strawberry_randomsolution.m
  function x = strawberry_randomsolution()
    global strawberry_lower
    global strawberry_upper
    r = rand(length(strawberry_lower),1);
    x = strawberry_lower + r.*(strawberry_upper-strawberry_lower);
  endfunction
#+end_src
** runners -- number a function of fitness
Two aspects define a plant propagation algorithm: the distance for the runners to propagate and the number of such runners that are generated.  This function addresses the latter.  The better the solution, defined by the fitness \(N\), the more runners should be generated.  The actual number of runners is \(\in [1,N_{r,max}]\) and is randomly generated.

#+begin_src octave :tangle strawberry_runners.m
  function nr = strawberry_runners(N, nrmax)
    r = rand();
    nr = ceil (nrmax*N*r); # number of runners
    if nr < 1, nr = 1; endif
    debugprint (4, ':runners N r runners max', [N, r, nr, nrmax])
  endfunction
#+end_src
** select -- tournament fitness based selection
Selection from the current population, for propagation of runners, is based on a sample size 2 *tournament* selection.  This could be generalised to have a greater number of individuals selected for a tournament, emphasising the most fit solutions.  Other selection approaches could of course be used instead.  Our experience is that this simple selection procedure is effective in balancing the global and local search aspects of a plant propagation algorithm.

The one modification we have with respect to the standard selection procedure is that we only select from those individuals that have not already been selected in the current generation.
#+begin_src octave :tangle strawberry_select.m
  function s = strawberry_select (N)
    ## select only from those solutions that have not been selected
    ## before, i.e. those with non-negative fitness values
    n = length(N);
    available = N >= 0;
    debugprint (4, 'select, available = ', available)
    na = sum(available);
    allpossibleindices = 1:n;
    indices = allpossibleindices(available);
    switch na
      case 0
        s = 0;                  #no solutions available.
      case 1
        s = indices(1);           #only one available so select it
      case 2
        if N(indices(1)) > N(indices(2))
          s = indices(1);
        else
          s = indices(2);
        endif
      otherwise
        i = ceil(na * rand(2,1));
        i(i>na) = na;
        i(i<1) = 1;
        if N(indices(i(1))) > N(indices(i(2)))
          s = indices(i(1));
        else
          s = indices(i(2));
        endif
    endswitch
    if s>0
      debugprint(5, 'select: s N(s)', [s, N(s)])
    else
      debugprint(5, 'select: none available for selection')
    endif
  endfunction
#+end_src
** sort -- for single criterion problems
For single criterion problems, we sort the population in order of decreasing fitness.  This is purely for the purpose of output and could be removed entirely.
#+begin_src octave :tangle strawberry_sort.m
  function pop = strawberry_sort (pop,nx,nz)
    [n m] = size(pop);
    ## sorting only makes sense in single criterion problems
    if nz == 1                    # single objective optimisation
      if n-nx == 2                # y + constraint violation
                                  # find feasible and infeasible sets
        feasible = pop(:, pop(n,:) <= 0);
        [s, i] = sort(feasible(nx+1,:)); # sort on objective function value
        feasible = feasible(:,i);        # sorted
        ## now check for infeasible solutions
        nfeasible = size(feasible,2);
        if nfeasible < size(pop,2)
          infeasible = pop(:, pop(n,:) > 0);
          [s, i] = sort(infeasible(n,:));
          infeasible = infeasible(:,i);
          pop = [feasible, infeasible];
        else
          pop = feasible;
        endif
      else
        error('Number of objective functions does not seem to match');
      endif
    endif
  endfunction
#+end_src
* Tests
#+toc: headlines 2 local
** general bicriteria test
#+begin_src octave :tangle no
strawberry_test
#+end_src 
#+begin_src octave :tangle strawberry_testobjective.m
  function [z g] = strawberry_testobjective(x)
    z = [ sum((x-0.5).^2+1)
          sum(cos(x))];
    g = 0;
  endfunction
#+end_src 
#+begin_src octave :tangle strawberry_test.m
  function [x z pareto fitness] = strawberry_test
    global esfdebug
    esfdebug = 0
    global strawberry_numberofprocessors
    strawberry_numberofprocessors = 1;
    x0 = [0 0 0 0 0]';
    a = zeros(5,1);
    b = ones(5,1);
    printf('Testing bicriteria problem with %d decision variables\n', length(x0))
    printf('starting with initial point '), x0
    z0 = strawberry_testobjective(x0)
    printf('which has objective %d function values ', length(z0))
    for i=1:length(z0)
      printf('%f ', z0(i))
    endfor
    printf('\n')
    ## [x y nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output, g)
    [x z nf ninf bestgen] = strawberry(x0, a, b, @strawberry_testobjective, 200, 50);
    paretoset = z(1:2, findpareto(z(1:2,:)));
    [zz indices] = sort(paretoset(1,:));
    paretoset = paretoset(:,indices)
    plot(paretoset(1,:),paretoset(2,:),'- r',z(1,:),z(2,:),' *g')
#+end_src
** three criteria test
This is simple test of three criteria.  The results can be seen in the following plot which shows the solutions in the Pareto set at the end.

#+name: test3criteriaplot
#+begin_src gnuplot :results file :export results :file "strawberry_test3.png"
  reset
  unset key
  set xlabel 'f_1'
  set ylabel 'f_2'
  set zlabel 'f_3'
  set xyplane 0
  set xrange [4.75:6.6]
  set xtics 5,0.5
  set yrange [2.5:5.25]
  set ytics 3,0.5
  set zrange [0:6]
  set ztics 0,2
  set view 50,280
  splot 'strawberry_test3.data' with impulses
#+end_src 

#+results: test3criteriaplot
[[file:strawberry_test3.png]]

#+name: test3criteriaobjective
#+begin_src octave :tangle strawberry_test3objective.m
  function [z g] = strawberry_test3objective(x)
    z = [ sum((x-0.5).^2+1)
          sum(cos(x))
          sum(sin(x))];
    g = 0;
  endfunction
#+end_src 
#+name: test3criteria
#+begin_src octave :tangle strawberry_test3.m
  function [x z paretoset] = strawberry_test3
    global esfdebug
    esfdebug = 0
    global strawberry_numberofprocessors
    strawberry_numberofprocessors = 1;
    global strawberry_fitness_method
    strawberry_fitness_method = 0
    global strawberry_output_population
    strawberry_output_population = 100
    x0 = [0 0 0 0 0]';
    a = zeros(5,1);
    b = ones(5,1);
    printf('Testing three criteria problem with %d decision variables\n', length(x0))
    printf('starting with initial point '), x0
    z0 = strawberry_test3objective(x0);
    printf('which has objective %d function values ', length(z0))
    for i=1:length(z0)
      printf('%f ', z0(i))
    endfor
    printf('\n')
    ## [x y nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output, g)
    [x z nf ninf bestgen] = strawberry(x0, a, b, @strawberry_test3objective, 1000, 20)
    paretoset = z(1:3, findpareto(z(1:3,:)));
    [zz indices] = sort(paretoset(1,:));
    paretoset = paretoset(:,indices)
    plot3(paretoset(1,:),paretoset(2,:), paretoset(3,:),'- r',z(1,:),z(2,:), z(3,:),' *g')
#+end_src
** testing the use of alternative random solutions and neighbour generation for mixed integer problems
The assumption is that Strawberry itself needs no special knowledge to work with integer variables.  The problem encoded here is from [[file:~/hg/jacaranda/inputs/minlp/westerlund/icheap6.in][Westerlund]].  This test case exercises three elements:
1. the random generation of solutions in the search space
2. the generation of neighbouring solutions
3. the use of constraints
*** helper functions for solution generation
We need to define two functions:

1. generate a random solution in the search space
   #+begin_src octave :tangle mitestrandom.m
     function x = mitestrandom()
       x = [ 1+5*rand()
             1+round(6*rand()-0.5)];
       x(x>6) = 6;
     endfunction
   #+end_src
2. generate a neighbouring solution based on the fitness
   #+begin_src octave :tangle mitestneighbour.m
     function x = mitestneighbour(x0,f)
       x = x0 + (1-f)*(rand(length(x0),1)-0.5)*5;
       x(2) = round(x(2));
       x(x<1) = 1;
       x(x>6) = 6;
     endfunction
   #+end_src
*** the actual problem and solution method
The objective function and constraints are defined in a single Octave function.  The value of the objective function is simple; there are three constraints, all meant to be less than or equal to 0.  ~g~ will be true if any of the constraints are violated.
#+name: mitestf
#+begin_src octave :tangle "mitestf.m"
  function [f g] = mitestf(x)
    f = 3*x(2)-5*x(1);
    g = max([ 2*x(2) + 3*x(1) - 24;
              3*x(1) - 2*x(2) - 8;
              2*x(2)^2 - 2*sqrt(x(2)) + 11*x(2) + 8*x(1) - 39 - 2*sqrt(x(1))*x(2)^2 ]);
  endfunction
#+end_src

Strawberry is used on this objective function within a simple rectangle domain.

#+name: mitest
#+begin_src octave :results output :tangle "mitest.m"
  global esfdebug
  esfdebug = 0
  global strawberry_numberofprocessors
  strawberry_numberofprocessors = 1;
  global strawberry_randomsolutionfn
  strawberry_randomsolutionfn = @mitestrandom;
  global strawberry_neighbourfn
  strawberry_neighbourfn = @mitestneighbour;
  a = [1;1];
  b = [6;6];
  x0 = [4;1];
  ngen = 100;
  npop = 10;
  nrmax = 5;
  ns = 1000;                       #number of stable generations
  population_strategy = 4;
  output = 10;
  [x y nf ninf bestgen] = strawberry(x0, a, b, @mitestf, ngen, npop, nrmax, ns, population_strategy, output)
#+end_src 

* Recent change history
#+name: changehistoryshellblock
#+begin_src shell :exports results :results output
hg log --template "{date|shortdate} {desc|firstline}\n" --limit 10 strawberry.org
#+end_src
* Log of requests for code                                    :noexport:
** [2017-10-29 Sun] "Ali Shujaat.." <ali_shujaat@live.com>
- Subject :: .m file for Modified PPA Algorithm
- Email :: [[gnus:nnimap+ericatucl:general#b5356a5cc9c241e78648eb3dfde00f35@HE1PR01MB1898.eurprd01.prod.exchangelabs.com][Email from Ali Shujaat..: .m file for Modified PPA Algor]]

* settings                                                    :noexport:
** org startup on file visit
#+name: startup
#+begin_src emacs-lisp :results none
  (setq-local htmlize-output-type 'inline-css)
  (setq-local org-publish-project-alist
              '(("strawberry"
                 :base-directory "~/s/research/strawberry/src"
                 :publishing-directory "/ssh:socrates.ucl.ac.uk:html.pub/"
                 :include ("strawberry.org")
                 :publishing-function org-html-publish-to-html
                 :html-preamble "<!-- the preamble goes here -->\n"
                 :html-postamble "<!-- the postamble -->
  <!-- twitter logo -->
  <a href=\"http://www.twitter.com/ericsfraga\"><img src=\"http://twitter-badges.s3.amazonaws.com/t_logo-b.png\" alt=\"Follow ericsfraga on Twitter\"/></a>
  <!-- created with org image and link to org mode -->
  <a href=\"http://orgmode.org/\"><img src=\"./images/org-mode.png\"></a>
  <!-- linkedin -->
  <a href=\"http://uk.linkedin.com/pub/eric-fraga/23/b45/247\"><img src=\"http://www.linkedin.com/img/webpromo/btn_viewmy_120x33.png\" width=\"120\" height=\"33\" border=\"0\" alt=\"View Eric Fraga's profile on LinkedIn\"></a>
  %a (%e)."
                 :author "Professor Eric S Fraga"
                 :email "e.fraga@ucl.ac.uk"
                 :style "<link rel=\"stylesheet\" type=\"text/css\" href=\"http://orgmode.org/worg/worg.css\" />"
                 )))
#+end_src
** emacs local variables

# Local Variables:
# eval: (esf/execute-startup-block)
# time-stamp-line-limit: 1000
# time-stamp-format: "%04y.%02m.%02d %02H:%02M:%02S"
# time-stamp-active: t
# time-stamp-start: "version = '"
# time-stamp-end: "';"
# End:

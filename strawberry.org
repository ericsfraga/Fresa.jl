#+INCLUDE:   /home/ucecesf/hg/homepages/level-0.org
#+title: Strawberry plant propagation algorithm
#+options: num:nil ^:nil

* Overview and introduction
Below is the code I have written to implement a /plant propagation algorithm/.  It is based on the algorithm Professor Abdellah Salhi and I developed from his original insight into the propagation of strawberry plants.  The basis of the code in this particular repository is the code used for the results presented in a paper on the modelling of energy systems for domestic dwellings ([[http://dx.doi.org/10.1260/1748-3018.9.1.13][Fraga et al., 2015]]).  This code was in turn based on the code used for the original paper ([[https://www.researchgate.net/publication/252321319_Nature-Inspired_Optimisation_Approaches_and_the_New_Plant_Propagation_Algorithm][Salhi & Fraga, 2011]]).  The multi-objective ranking method for fitness evaluation has been described in an up-coming publication ([[http://www.springer.com/gb/book/9783319299730][Fraga & Amusat, 2016]]).

The /Strawberry/ algorithm has been implemented in the [[http://www.gnu.org/software/octave/][Octave]] programming language.  A MATLAB compatible (untested) version, automagically generated from the Octave code, can be requested but it should be notes that the author prefers to use open source software.  This document, for instance, has been written using [[http://orgmode.org/][org mode]] in the [[https://www.gnu.org/software/emacs/][Emacs]] text editor.  Org allows for /literate programming/ and uses /tangling/ to generate the actual source files for the code. In any case, bug reports based on the Octave code will be most welcome.

In the following code, we assume column vectors for decision variables and objectives.  The convention on constraint violation is 1 meaning yes, i.e. infeasible solution, and 0 means no violation of the constraints.

All code is copyright Â© 2016, Eric S Fraga, all rights reserved.  Permission is given to use this code for evaluation purposes.  If the /Strawberry/ code is used, please do let the authors know and the above publications must be cited in any research papers written.  The code is made available with no warranty or guarantee of any kind.  Use at own risk.  Some supplementary functions are required for the /Strawberry/ method (utility functions, multi-objective genetic algorithm (MOGA), and multi-objective steepest descent (MOSD)) and these are available from the author upon request.

Feedback, including bug reports, is most welcome.

** Code for converting from octave to MATLAB                 :noexport:
Code for doing this can be found [[file:~/s/research/others/dimitrios.gerogiorgis/modo.org::*Distribution%20of%20code][in the MODO work with Edinburgh]].
* Version information

Major version log:

- July 2016 :: multi-objective version extended to work for any number of criteria instead of just 2.
- October 2015 :: started work on a MI-Strawberry version, hopefully as upwards compatible as possible.
- September 2015 :: implemented a rank based fitness, used to prepare results in [[file:~/synced/research/multiobjective.optimisation/strawberry/paper.pdf][the paper on understanding the impacts of constraints]].  There is now a choice of fitness functions as the old, Pareto based, fitness function is still available (cf. Deb (2000) for an example).

#+name: version
#+begin_src octave :tangle strawberry_initialise.m
  function strawberry_initialise
    global strawberry_version
    global strawberry_octave
    global moga_version
    global mosd_version
    if isempty (strawberry_version)
      strawberry_version = "2016.09.02 17:00:24";
      mosd_initialise
      moga_initialise
      printf (": STRAWBERRY %s, main function\n", strawberry_version)
      printf (": using MOSD %s, multi-objective steepest descent method.\n", mosd_version)
      printf (": and MOGA %s, multi-objective genetic algorithm fitness function.\n", moga_version)
      strawberry_octave = exist ("OCTAVE_VERSION", "builtin") > 0
      if strawberry_octave
        pkg load parallel             #need parcellfun in particular
      endif
    endif
#+end_src
* TODO [0/9] improvements or bugs                             :noexport:
- [ ] handling /uncertainty/ in strawberry with either probability distribution functions (*pdf*) or intervals.  The latter should be easier and possibly sufficient.
- [ ] *mixed-integer* Strawberry:
  - could we get away with not change anything in the main code but assume that the user passes a function which maps a given solution vector /x/ to a new one, taking care of rounding, e.g. for integer variables?
- [ ] should propagate each individual only once, i.e. select (whether with tournament selection or otherwise) an individual only once so remove it from subsequent selection steps
- [ ] should only evaluate new points, whether in parallel or not
- [ ] consider only accepting solutions if they improve on the parent, possibly using a form of /Metropolis-Hastings/ acceptance rule as used in simulated annealing.
- [ ] need to handle the case of the Pareto set becoming ever larger, potentially infinite in size.  We should prune the set somehow.
- [ ] consider resource availability.  I wrote this after the EGH 2015 meeting and I am not sure exactly what I meant but it could be that we shouldn't allow too many solutions in the same place so maybe some form of diversity control?  not sure.
- [ ] consider killing plants off after a certain number of generations, but keeping an overall /best/ solution record to ensure we don't lose the best solution found overall.  In terms of multi-objective optimisation, this may mean keeping an elite set of non-dominated solutions.
- [ ] can we make the code available externally, e.g. on a web site?  If so, we need to bring in the MOGA codes into this code base.  This may not be a bad idea in any case but it does limit code re-use.
* distance
The distance method determines how far to send a runner.  The first argument is the fitness, \(f \in [0,1]\), and the second is the dimension of the problem, \(n>0\), i.e. the number of decision variables.  

The basic premise is that the fitter the solution, the less far runners are sent as there is plenty of /food/ in this local neighbourhood.  A less fit point will send runners further.
#+begin_src octave :tangle strawberry_distance.m
  function d = strawberry_distance(f,n)
    d = (1-f) * 2*(rand(n,1)-0.5);
  endfunction
#+end_src
* fitness

The fitness of the members in the population is calculated differently for 1 criterion problems and multi-criteria problems.  The former is based on a scaled value within the range of values for feasible and infeasible solutions separately.

For multi-objective problems, we have a number of options.  We can use the approach we used in [[http://dx.doi.org/10.1080/03052150903074189][MOGA]]  which was based on distance to the Pareto set of non-dominated solutions.  However, this has a problem when the set is large compared with the total population size.  Also, it does not necessarily push towards the endpoints of the Pareto front which is often, in the problems we consider, what we want.

To accomplish the latter, we consider a ranking that takes into account how good each individual objective value is within its own set of values.  If we consider a fitness 1,... for each point for each objective, and then multiply these two ranking values together, this should emphasise the end-points.  The multiplication of vectors of rankings in known as the [[https://en.wikipedia.org/wiki/Hadamard_product_(matrices)][Hadamard]] product.

#+begin_src octave :tangle strawberry_fitness.m
  function [fit, best] = strawberry_fitness(p,nx,nz,npop)
    global strawberry_fitness_method 
    [n m] = size(p);
    debugprint (1, "fitness, nx nz m n npop", [nx, nz, m, n, npop])
    if m <= 0
      disp("No solutions in the population");
    endif
    if nz == 1                    #single objective optimisation
      if n-nx == 2                # two extra columns: y and constraint
                                  # violation
        indexfeasible = p(n,:) <= 0;
        indexinfeasible = p(n,:) > 0;
        debugprint(2, "fitness: indexfeasible = ", indexfeasible)
        ## there are potentially three cases: all feasible, all
        ## infeasible or a mix of both.  We want the fitness values
        ## assigned to cover the range [0,1] so the values given will
        ## depend on which case we have.  Note that a value of 1 means
        ## "more fit"
        if sum(indexfeasible) > 0
          ymin = min(p(nx+1, indexfeasible));
          ymax = max(p(nx+1,indexfeasible));
          if sum(indexinfeasible) > 0
            ## case 1: both feasible and infeasible points in the
            ## population so feasible points take top half of the
            ## fitness range and infeasible the bottom half.
            if abs(ymax-ymin) > 1e-4
              fit(indexfeasible) = 0.5+0.5*(ymax-p(nx+1,indexfeasible))/(ymax-ymin);
            else                  # all equivalently good, I guess
              fit(indexfeasible) = 0.75;
            endif
            cmin = min(p(n,indexinfeasible));
            cmax = max(p(n,indexinfeasible));
            if abs(cmax-cmin) > 1e-4
              fit(indexinfeasible) = 0.5*(cmax-p(n,indexinfeasible))/(cmax-cmin);
            else
              fit(indexinfeasible) = 0.25;
            endif
          else                    # only feasible solutions present in population
            if abs(ymax-ymin) > 1e-4
              fit(indexfeasible) = (ymax-p(nx+1,indexfeasible))/(ymax-ymin);
            else                  # all equivalently good, I guess
              fit(indexfeasible) = 0.5;
            endif
          endif
        else                      # all infeasible
          cmin = min(p(n,:));
          cmax = max(p(n,:));
          if abs(cmax-cmin) > 1e-4
            fit = (cmax-p(n,:))/(cmax-cmin);
          else
            fit = 0.5*ones(1,m);
          endif
        endif
        debugprint(1, "objective function values", p(n-1,:))
        debugprint(1, "fitness values", fit)
        [bestfit bestindex] = max(fit);
        debugprint(1, "bestfit, bestindex", [bestfit, bestindex])
        best = p(:, bestindex);
      else
        error("Number of objective functions doesn't seem to match");
      endif

    else        # multi-objective case

      debugprint(4, "fitness: method ", strawberry_fitness_method)
      debugprint(4, "fitness: nx nz", [nx, nz])

      if strawberry_fitness_method == 0
        ## rank based fitness using ranking of all objectives
        z = p(nx+1:nx+nz,:);    #extract out the objective function values
        rank = ones(nz,m);      #for collating the rank of each solution for each objective function 
        for i=1:nz
          [zz ind] = sort(z(i,:));
          rank(i,ind) = 1:m;
          best(:,i) = p(:,ind(1));
        endfor
        fitness = prod(rank,1);   #Hadamard product of rankings
        fit = 1 - fitness / max(fitness); #normalise and reverse meaning (1=best, 0=worst)
        debugprint(5, "fitness.rank: ", rank)
        debugprint(5, "fitness.fit  : ", fit)
        debugprint(5, "best solutions: ", best)
        ## extract the best member for each criterion
        ## ## we also need to extract the set of non-dominated points
        ## bestindices = findpareto (z);
        ## bestunsorted = p(:,bestindices);
        ## [xx bestsortedindices] = sort(bestunsorted(nx+1,:));
        ## best = bestunsorted(:,bestsortedindices);

      elseif strawberry_fitness_method == 1 #MOGA fitness

        ## use the MOGA fitness function as it is generic
        ## enough.  However, the MOGA fitness doesn't know about
        ## infeasible solutions so we need to split the current solution
        ## into feasible and infeasible solutions.
        fitindices = p(nx+1,:) < 1e19;
        ## fprintf(stderr,"%d feasible points\n", sum(fitindices))
        [fitness pareto] = moga_fitness ( p(1:nx,fitindices), p(nx+1:nx+nz,fitindices));
        debugprint(3,": fitness", fitness)
        debugprint(3,": pareto.x", pareto.x)
        debugprint(3,": pareto.z", pareto.z)
        npareto = size(pareto.x,2);
        best = [pareto.x ; pareto.z ; zeros(1,npareto)];
        ## MOGA fitness is 0 for best and positive values for less good so we reverse and scale [0,1]
        maxfit = max(fitness);
        if abs(maxfit) < 1e-6
          fit = ones(size(fitness));
        else
          fit = 1 - fitness/maxfit;
          debugprint(3,": rescaled fitness", fit)
        endif
      else
        error('Strawberry fitness strategy %d not recognised.\n', strawberry_fitness_method)
      endif                       #end of which fitness method to use
    endif                         #end of single versus multi-objective
    ## finally, at the end, transform the fitness values calculated
    ## above, which are in [0,1], so that they are in (0,1) with a
    ## sigmoid shape, emphasising the top solutions, not just the best,
    ## over the bottom solutions.
    fit = (tanh(4*fit-2)+1)/2;
    debugprint (3, ": and fitness reshaped to sigmoid", fit)
    if min(fit) < 0 || max(fit) > 1
      printf("Ummm fitness range at end: [%g,%g]\n", min(fit), max(fit));
      error ("Fitness should always be in [0,1]");
    endif
  endfunction
#+end_src
* isdiverse
We only want to add solutions to the population that are diverse, i.e. significantly different, from those that are already there.  However, the diversity control should not be at the expense of losing better solutions.  The current implementation is not good in this respect and should be used with care as a result.
#+begin_src octave :tangle strawberry_isdiverse.m
  function diverse = strawberry_isdiverse (pop, x)
    global nsimilar
    global strawberry_diversity_tolerance
    i = 0;
    diverse = 1;
    while i < length(pop) && diverse
      diverse = norm(pop{i}-x) > strawberry_diversity_tolerance;
      i = i + 1;
    endwhile
    if ! diverse, nsimilar = nsimilar + 1; endif
  endfunction
#+end_src
* newpopulation
Create a random population, distributed uniformly (hopefully) throughout the domain defined by the lower and upper bounds of the optimisation variables.
#+begin_src octave :tangle strawberry_newpopulation.m
  function [pop, nx, nz, nf, ninf] = strawberry_newpopulation (x0,a,b,npop,f,constrained,g)
    global strawberry_numberofprocessors
    nx = length(x0)
    nf = 0;
    ninf = 0;
    pop = [];                     # will be array of x+y values
    n = 0;
    ntries = 0;
    xcell{1} = x0;                        # start with initial guess

    for i=2:npop
      r = rand(nx,1);
      xcell{i} = a + r.*(b-a);
    endfor
    if strawberry_numberofprocessors > 1
      if constrained 
        pop = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); g(x)], xcell, "VerboseLevel", 0);
      else 
        pop = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); 0], xcell, "VerboseLevel", 0);
      endif 
    else
      x = xcell{1};
      if constrained
        y = [x; f(x); g(x)];
      else
        y = [x; f(x); 0];
      endif 
      pop = zeros(length(y),npop);
      pop(:,1) = y;
      for i=2:npop
        x = xcell{i};
        if constrained
          pop(:,i) = [x; f(x); g(x)];
        else
          pop(:,i) = [x; f(x); 0];
        endif
      endfor
      ## pop = cellfun (@(x) [x; f(x); 0], xcell);
    endif
    if constrained
      pop = pop(:,pop(end,:) <= 0);
    else
      pop = pop(:,pop(nx+1,:)<1e19)
    endif
    [n m] = size(pop);
    ## each row consists of nx x values, nz y values and a feasibility indication
    nz = n-nx-1
  endfunction
#+end_src
* prune
Especially for multi-objective problems, we have a problem with diversity in that the pareto set forms an *elite* set.  If this set has multiple copies of the same solutions, the set can grow quite large and increases the computational effort dramatically with little effect on the quality of the solutions obtained.
#+begin_src octave :tangle strawberry_prune.m
  function pruned = strawberry_prune (pop, nx, nz)
    global npruned
    global strawberry_diversity_tolerance
    npop = size(pop,2);
    if npop > 0
      pruned = pop(:,1);
      np = 1;                       # size of pruned set
      for i=2:size(pop,2)
        diverse = 1;
        j = 0;
        while diverse && j < np
          j = j + 1;
          ## diversity based on x values alone
          diverse = norm (pop(1:nx,i)-pruned(1:nx,j)) > strawberry_diversity_tolerance;
        endwhile
        if diverse
          pruned = [pruned, pop(:,i)];
          np = np + 1;            #keep track of how many copied over
        else
          ## prune one or the other.  ideally, we keep the better
          ## one.  If we cannot distinguish (in a multi-objective
          ## sense), we simply keep the one that is already there. 
          if ! dominates(pruned(nx+1:nx+nz,j),pop(nx+1:nx+nz,i))
            if dominates(pop(nx+1:nx+nz,i),pruned(nx+1:nx+nz,j))
              ## current solution is better, i.e. dominates, than previous
              ## one so replace
              pruned(:,j) = pop(:,i);
              npruned = npruned + 1;
            endif
          else
            ## previous solution better, i.e. dominates
            npruned = npruned + 1;
          endif
        endif
      endfor
    endif
  endfunction
#+end_src
* runners
Two aspects define a plant propagation algorithm: the distance for the runners to propagate and the number of such runners that are generated.  This function addresses the latter.  The better the solution, defined by the fitness \(N\), the more runners should be generated.  The actual number of runners is \(\in [1,N_{r,max}]\) and is randomly generated.

#+begin_src octave :tangle strawberry_runners.m
  function nr = strawberry_runners(N, nrmax)
    r = rand();
    nr = ceil (nrmax*N*r); # number of runners
    if nr < 1, nr = 1; endif
    debugprint (4, ":runners N r runners max", [N, r, nr, nrmax])
  endfunction
#+end_src
* select
Selection from the current population, for propagation of runners, is based on a sample size 2 *tournament* selection.  This could be generalised to have a greater number of individuals selected for a tournament, emphasising the most fit solutions.  Other selection approaches could of course be used instead.  Our experience is that this simple selection procedure is effective in balancing the global and local search aspects of a plant propagation algorithm.

The one modification we have with respect to the standard selection procedure is that we only select from those individuals that have not already been selected in the current generation.
#+begin_src octave :tangle strawberry_select.m
  function s = strawberry_select (N)
    ## select only from those solutions that have not been selected
    ## before, i.e. those with non-negative fitness values
    n = length(N);
    available = N >= 0;
    debugprint (4, "select, available = ", available)
    na = sum(available);
    indices = (1:n)(available);
    switch na
      case 0
        s = 0;                  #no solutions available.
      case 1
        s = indices(1);           #only one available so select it
      case 2
        if N(indices(1)) > N(indices(2))
          s = indices(1);
        else
          s = indices(2);
        endif
      otherwise
        i = ceil(na * rand(2,1));
        i(i>na) = na;
        i(i<1) = 1;
        if N(indices(i(1))) > N(indices(i(2)))
          s = indices(i(1));
        else
          s = indices(i(2));
        endif
    endswitch
    if s>0
      debugprint(5, "select: s N(s)", [s, N(s)])
    else
      debugprint(5, "select: none available for selection")
    endif
  endfunction
#+end_src
* sort
For single criterion problems, we sort the population in order of decreasing fitness.  This is purely for the purpose of output and could be removed entirely.
#+begin_src octave :tangle strawberry_sort.m
  function pop = strawberry_sort (pop,nx,nz)
    [n m] = size(pop);
    ## sorting only makes sense in single criterion problems
    if nz == 1                    # single objective optimisation
      if n-nx == 2                # y + constraint violation
                                  # find feasible and infeasible sets
        feasible = pop(:, pop(n,:) <= 0);
        [s, i] = sort(feasible(nx+1,:)); # sort on objective function value
        feasible = feasible(:,i);        # sorted
        ## now check for infeasible solutions
        nfeasible = size(feasible,2);
        if nfeasible < size(pop,2)
          infeasible = pop(:, pop(n,:) > 0);
          [s, i] = sort(infeasible(n,:));
          infeasible = infeasible(:,i);
          pop = [feasible, infeasible];
        else
          pop = feasible;
        endif
      else
        error("Number of objective functions doesn't seem to match");
      endif
    endif
  endfunction
#+end_src
* strawberry
The algorithm is *evolutionary*, iterating over a number of generations.  In each generation, the solutions are ranked according to the objective function values.  In each generation, a number are selected for *propagation*.  Each solution can propagate itself a number of times and a certain distance with both aspects being a function of the solution's fitness.  The best solutions propagate more but for shorter distances to exploit the quality of the solution, i.e. a /local/ search; the not so good solutions propagate less but further to explore the domain, i.e. a /global/ search.

A hybrid procedure using a multi-objective steepest descent method, ~MOSD~, is optional.

All of the following ~src~ blocks will be *tangled* to the same [[file:strawberry.m][strawberry.m]] file.
** function definition
#+begin_src octave :noweb yes :tangle strawberry.m
  function [x z nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output, g)
#+end_src
*** Arguments
The function has the following arguments:
- x0 :: initial member of the population of solutions
- a :: lower bounds on all variables
- b :: upper bounds for all variables
- f :: handle for the objective function which has signature ~z = f(x)~.
- ngen :: one of the stopping criteria: maximum number of generations of plant propagation to allow
- npop :: the base number in the population.  The actual number will be larger, depending on the value of ~nrmax~.  ~npop~ decides how many plants actually propagate but the number of new solutions depends on the fitness of those chosen to propagate and the maximum number of runners allowed, ~nrmax~.
- nrmax :: the maximum number of runners to create for any solution if chosen to propagate.
- ns :: a stopping criterion based on the number of consecutive generations for which no new /best/ solution is found.
- population_strategy :: The strategy to use for creating a new population after the propagation of chosen solutions:
     The strategy to use for creating a new population after the propagation of chosen solutions:
  1. newly created solutions (propagated) alone
  2. newly created solutions along with those selected for propagation
  3. the /best/ from the current population, where /best/ will be a single solution for single objective optimisation and a set of /non-dominated/ solutions for multi-objective optimisation.
  4. union of the /best/, the /selected/ and the /new/ solutions.
- output :: An integer indicating how often to output statistics about the search.
- g :: The function handle for the constraints, if any.  This function, with signature ~p = g(x)~, is expected to return a 0 value if the point ~x~ is feasible and a positive value otherwise.  The positive value could be a measure of the infeasibility and could be used in fitness evaluation (e.g. for identifying non-dominated solutions if all are unfeasible).


In all of the above, vectors (solutions and objective function values for multi-objective optimisation) are column vectors.

Only the first four arguments, ~x0~, ~a~, ~b~ and ~f~, are required.  The rest are optional and default to the following values:
|---------------------+---------|
| ngen                |    1000 |
| npop                |     100 |
| nrmax               |       5 |
| ns                  |     100 |
| population_strategy |       4 |
| output              | ngen/50 |
|---------------------+---------|
There is no default for ~g~.  If present, it is used; if not, the problem is assumed to be unconstrained although the objective function could be defined to include a penalty function.  The code does assume that a value of the objective function(s) of 10^{20} is an infeasible solution.
*** Return values
The function returns the best point found, ~x~, with associated objective function values, ~z~.  It also returns information on the search:
- ~nf~ :: number of objective function evaluations.
- ~ninf~ :: number of infeasible function evaluations.
- ~bestgen~ :: the generation in which the best solution, ~<x,z>~, was obtained.
For multi-objective optimisation, ~x~ and ~z~ will be a set of points and associated objective function values.
** initialisation
#+begin_src octave :noweb yes :tangle strawberry.m
  global esfdebug
  global mosd_numberimproved
  global npruned
  global nsimilar
  global strawberry_fitness_method
  global strawberry_diversity_tolerance
  mosd_numberimproved = 0;
  npruned = 0;
  nsimilar = 0;
  warning ("error", "Octave:broadcast");
  ## process arguments
  constrained = nargin > 10;    # has a constraint function been passed?
  if nargin<9, population_strategy = 4; end # population selection strategy
  if nargin<8, ns = 100; end    # number of stable generations
  if nargin<7, nrmax = 5; end   # number of runners
  if nargin<6, npop = 100; end  # population size
  if nargin<5, ngen = 1000; end # number of generations
  if nargin<4
    disp("Error: need at least 4 arguments to Strawberry method: x0, a, b & f.")
    return
  end
  if nargin<10, 
    output = ngen/50;
  end             # how often to output status of population
  if isempty (strawberry_fitness_method)
    strawberry_fitness_method = 1;  #choose MOGA fitness for now
  end
  strawberry_diversity_tolerance = norm(b-a) / 1000;
  printf(": ngen=%d npop=%d nrmax=%d ns=%d population strategy=%d and tolerance=%f fitness method=%d\n", ngen, npop, nrmax, ns, population_strategy, strawberry_diversity_tolerance, strawberry_fitness_method)

  ## determine the number of processors to use in parallel.  If the
  ## variable has not been set, we use the system function to determine
  ## how many processors there are
  global strawberry_numberofprocessors
  if isempty(strawberry_numberofprocessors)
    strawberry_numberofprocessors = nproc();
  endif
  if strawberry_numberofprocessors > 1
    printf (": using %d processors for parallel processing.\n", strawberry_numberofprocessors);
    starttime = time;           # use wall clock time instead of CPU time
  else
    printf (": not using any parallel processing on a single processor system.\n");
    starttime = cputime;
  endif
#+end_src
** initial population
#+begin_src octave :noweb yes :tangle strawberry.m
  if constrained
    [phi, nx, nz, nf, ninf] = strawberry_newpopulation (x0,a,b,npop,f,constrained,g);
  else
    [phi, nx, nz, nf, ninf] = strawberry_newpopulation (x0,a,b,npop,f,constrained);
  endif
  pop = strawberry_sort (phi,nx,nz);
  gen = 0;

  if nz < 2
    best = pop(:,1);
  else
    best = [];
  endif
  bestgen = gen;
  nfunctionevaluations = npop; # initial population size

  if output
    printf("| %9s |", "gen")
    if nz > 1
      for i=1:nz, printf(" %6sz%02d |", "", i); endfor
    else
      for i=1:nx; printf(" %6sx%02d |", "", i); endfor
      for i=1:nz; printf(" %6sy%02d |", "", i); endfor
      if constrained; printf(" %9s |", "c"); endif
    endif
    printf(" %9s | %9s | %9s |", "$n_f$", "CPU (s)", "Best iter")
    printf("\n");
    printf("|-\n");
  endif
#+end_src
** iterate
#+begin_src octave :noweb yes :tangle strawberry.m
  while gen < ngen && (nz > 1 || gen < bestgen+ns)
    gen = gen + 1;
#+end_src
*** calculate fitness and prune
#+begin_src octave :noweb yes :tangle strawberry.m
  if nz > 1
    ## remove infeasible solutions from the population
    fitindices = pop(nx+1,:) < 1e19;
    if sum(fitindices) < size(pop,2)
      fprintf(stderr, "Removing %d solutions from population of %d.  \n", size(pop,2)-sum(fitindices), size(pop,2))
      pop = pop(:,fitindices);
    endif
  endif
  ## prune the solution, removing duplicate members as they contribute nothing
  pop = strawberry_prune (pop, nx, nz);
#+end_src
*** rank solutions
The fitness method is used to find the best members of the population and assign each one a ranking N \in (0,1) with higher values better than lower values.  

In the multi-objective case, the pareto front is combined with the elite set, a new pareto front is identified and duplicates are removed.  The elite set does not get involved in the selection and propagation.
#+begin_src octave :noweb yes :tangle strawberry.m
  ## evaluate the fitness of the population.  For multi-objective problems,
  ## this has the side effect of returning the pareto front 
  [N pareto] = strawberry_fitness (pop,nx,nz,size(pop,2));
  ## keep track of best.  For multi-objective problems, this means keeping the pareto set
  debugprint(1, "best", best)
  debugprint(1, "pareto", pareto)
  debugprint(1, "pop(1)", pop(:,1))
  debugprint(1, "nx, nz", [nx, nz])
  if nz < 2 && pareto(nx+1) < best(nx+1) && norm(abs(best(1:nx)-pareto(1:nx))) > 1e-6
    best = pareto;
    bestgen = gen;
    ## zzz = zfit (best (1:nx))
    if !output
      printf("\n... new best solution at generation %d, z(1)=%g x=", gen, best(nx+1));
      printf("%g ", best(1:nx));
      printf("\n");
    endif
  elseif nz>1
    ## the set of points returned by the fitness function is not really
    ## a pareto set.  it is one point for each criterion.  we compare
    ## these points to the existing ones and update if necessary.
    if isempty(best)
      best = pareto;
    else
      if size(pareto,2) > 1 && size(best,2) > 1
        for i = 1:2
          if pareto(nx+i,i) < best(nx+i,i)
            best(:,i) = pareto(:,i);
            bestgen = gen;
          endif
        endfor
      else
        if pareto(nx+1,1) < best(nx+1,1)
          best(:,1) = pareto(:,1);
          bestgen = gen;
        endif
      endif
    endif
    debugprint (1, "size of pareto: ", length(best))
  endif
#+end_src
*** output statistics if desired
#+begin_src octave :noweb yes :tangle strawberry.m
  if 0 == mod(gen,output)
    if strawberry_numberofprocessors > 1
      dtime = time-starttime;
    else
      dtime = cputime-starttime;
    endif
    fprintf(stderr, "\r");
    printf("| %9d |", gen);
    if nz > 1
      printf (" %9.3g |", min(best(nx+1:nx+nz,:),[],2))
      printf(" %9d | %9.1f | %9d |", nfunctionevaluations, dtime, bestgen);
    else
      printf (" %9.3g |", best(1:nx+nz))
      if constrained; printf(" %9.3g |", best(nx+nz+1)); endif
      printf(" %8d | %8.1f | %8d |", nfunctionevaluations, dtime, bestgen);
    endif
    printf("  \n");
  else
    if nz > 1
      ## [fitness pareto] = moga_fitness (pop(1:nx,:), pop(nx+1:nx+nz,:));
      fprintf(stderr, "\r%30s %7d %3d/%4d %9.3g %9.3g %9.3g %9.3g", "", gen, size(best,2), length(pop), best(nx+1:nx+nz,1), best(nx+1:nx+nz,end))
    else
      if constrained
        fprintf(stderr, "\r%30s %9d [%9d] %5d %13.6e %13.6e ", "", gen, bestgen, length(pop), best(nx+nz), best(nx+nz+1));
      else
        fprintf(stderr, "\r%30s %9d [%9d] %5d %8d %13.6e ", "", "", gen, bestgen, length(pop), nfunctionevaluations, best(nx+nz));
      endif
    endif
  endif

  debugprint (1,"strawberry: fitness", N);
  actualnpop = size(pop,2);
  if actualnpop < size (pop,2)
    printf("Ummmm size of population %d is less than expected (%d)\n", size(1,pop), npop);
  endif
#+end_src
*** select and propagate
#+begin_src octave :noweb yes :tangle strawberry.m
  ## generate all the new points and then evaluate them in parallel
  n = 1;
  newpop = [];
  selected = [];
  for p=1:npop                # we pick up to NPOP members to propagate
    s = strawberry_select (N);
    debugprint(2,"selected index", s)
    if s > 0
      selected(:,p) = pop(:,s);   # selected members remain for next generation; others die off
      debugprint(3, "selected fitness and point: ", [N(s), pop(:,s)']);
      nr = strawberry_runners (N(s),nrmax); # number of runners
      debugprint(2,": number of runners", nr)
      for r=1:nr
        dx = (b-a)/2 .* strawberry_distance (N(s),nx); # how far to run
        ## fprintf(stderr, "Selected %d with fitness %g to move %g\n", s, N(s), norm(dx))
        debugprint(3, ": r and dx", [r; dx(1:nx)])
        x = pop(1:nx,s)+dx;
        x(x<a) = a(x<a);        # reset boundary
        x(x>b) = b(x>b);        # reset boundary
        ## if strawberry_isdiverse(newpop,x)
        newpop{n} = x;
        n = n + 1;
        debugprint(2, ": added new member to population: ", x)
        ## endif
      endfor
      ## set fitness so this member is not selected again
      N(s) = -1;
    endif
  endfor
  debugprint(1,"Size of selected set: ", size(selected))
  debugprint(1,"Size of newpop: ", size(newpop))
  ## evaluate these in parallel using an appropriate number of processors
  ##parf = @(x) if length(x)>nx, x', else [x, f(x), 0]', endif
  ##phi = parcellfun (strawberry_numberofprocessors, parf, newpop)';

  if strawberry_numberofprocessors > 1
    if constrained
      phi = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); g(x)], newpop, "VerboseLevel", 0);
    else
      phi = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); 0], newpop, "VerboseLevel", 0);
    endif
  else
    n = length(newpop);
    x = newpop{1};
    y = f(x);
    phi = zeros(length(x)+length(y)+1,n);
    if constrained
      phi(:,1) = [x;y;g(x)];
    else
      phi(:,1) = [x;y;0];
    endif
    for i=2:n
      x = newpop{i};
      if constrained
        phi(:,i) = [x;f(x);g(x)];
      else
        phi(:,i) = [x;f(x);0];
      endif
    endfor
  endif
  nfunctionevaluations = nfunctionevaluations + length(phi);
  debugprint (1, ": phi before removal of infeasible solutions", phi)
  phi = phi(:,phi(nx+1,:)<1e19);
  debugprint (1, ": phi after removal of infeasible solutions", phi)
#+end_src
*** COMMENT apply local search
#+begin_src octave :noweb yes :tangle strawberry.m
  ## try to improve each of the new solutions using a local search
  ## procedure, or maybe only a single step or so of that procedure.
  ## for i=1:length(phi)
  ##   sdpop{i} = phi(1:nx,i);
  ## endfor
  ## function point = mosderrorhandler (s, f, x, a, b)
  ##   printf("Error %d: index %d message=%s\n: ", s.identifier, s.index, s.message)
  ## endfunction
  ## improvedset = parcellfun (strawberry_numberofprocessors, @(x) [mosd(f,x,a,b)], sdpop, "ErrorHandler", @mosderrorhandler);

  ## as we cannot figure out how to get parcellfun to do what we want, we use sequential processing here for the time being
  sdphi = zeros(size(phi));
  for i=1:size(phi,2)
    sdphi(:,i) = mosd (f, phi(1:nx,i), a, b);
  endfor
  ## combine the two and hope diversity check removes duplicates
  phi = [phi, sdphi];
#+end_src
*** create new population
#+begin_src octave :noweb yes :tangle strawberry.m
  ## sort the population, which is composed of the original NPOP
  ## best plus those created in this loop, using the fitness for
  ## sorting.
  ## we have three sets of solutions that we can combine to create a
  ## new population:
  ## 1. the best overall so far
  ## 2. the members selected from the previous generation for propagation
  ## 3. and the new propagated solutions
  ## there are therefore 3! combinations although we always should
  ## include the new solutions so really have 4 different options:
  ## new alone, new with best, new with selected and new with
  ## selected and best.

  ## fprintf(stderr, "size best=%d selected=%d phi=%d\n", size(best,2), size(selected,2), size(phi,2));
  switch (population_strategy)
    case 1               # new members alone
      pop = phi;
    case 2               # new with selected
      pop = [selected, phi];
    case 3               # new with best
      pop = [best, phi];
    case 4               # new with best and selected
      pop = [best, selected, phi];
    otherwise
      printf("Error: population strategy %d not recognised.", population_strategy)
  endswitch
#+end_src
** end loop and finish function
#+begin_src octave :noweb yes :tangle strawberry.m
  endwhile
  if gen < ngen
    printf("Strawberry: terminating condition satisfied due to lack of improvement at gen=%d\n", gen);
  endif
  if output
    printf("Strawberry: at end, nf=%d ninf=%d best solution:\n", nf, ninf)
    disp(best);
  endif
  ## ensure the best solution is returned
  pop = [best, pop];
  x = pop(1:nx,:);
  z = pop(nx+1:end,:);
  if strawberry_numberofprocessors > 1
    endtime = time;            # wall clock time
  else
    endtime = cputime;
  endif
  printf("\n: strawberry method elapsed time: %.1f with %d functions evaluated and %d solutions pruned with %d similar.\n", 
         endtime-starttime, nfunctionevaluations, npruned, nsimilar)
  printf("MOSD improvements: %d\n", mosd_numberimproved);
  endfunction
#+end_src
** COMMENT initialise: initialisation of arrays, processing arguments
#+name: initialise
#+begin_src octave :noweb yes
  strawberry_initialise
  global esfdebug
  global mosd_numberimproved
  global npruned
  global nsimilar
  global strawberry_fitness_method
  global strawberry_diversity_tolerance
  mosd_numberimproved = 0;
  npruned = 0;
  nsimilar = 0;
  warning ("error", "Octave:broadcast");
  ## process arguments
  if nargin<9, population_strategy = 4; end # population selection strategy
  if nargin<8, ns = 100; end    # number of stable generations
  if nargin<7, nrmax = 5; end   # number of runners
  if nargin<6, npop = 100; end  # population size
  if nargin<5, ngen = 1000; end # number of generations
  if nargin<4
    disp("Error: need at least 4 arguments to Strawberry method: x0, a, b & f.")
    return
  end
  if nargin<10, 
    output = ngen/50;
  end             # how often to output status of population
  if isempty (strawberry_fitness_method)
    strawberry_fitness_method = 1;  #choose MOGA fitness for now
  end
  strawberry_diversity_tolerance = norm(b-a) / 1000;
  printf(": ngen=%d npop=%d nrmax=%d ns=%d population strategy=%d and tolerance=%f fitness method=%d\n", ngen, npop, nrmax, ns, population_strategy, strawberry_diversity_tolerance, strawberry_fitness_method)

  ## determine the number of processors to use in parallel.  If the
  ## variable has not been set, we use the system function to determine
  ## how many processors there are
  global strawberry_numberofprocessors
                                  # strawberry_numberofprocessors = 1
  if isempty(strawberry_numberofprocessors)
    strawberry_numberofprocessors = nproc();
  endif
  if strawberry_numberofprocessors > 1
    printf (": using %d processors for parallel processing.\n", strawberry_numberofprocessors);
    starttime = time;           # use wall clock time instead of CPU time
  else
    printf (": not using any parallel processing on a single processor system.\n");
    starttime = cputime;
  endif

  constrained = nargin > 10;    # has a constraint function been passed?
  if constrained
    [phi, nx, nz, nf, ninf] = strawberry_newpopulation (x0,a,b,npop,f,constrained,g);
  else
    [phi, nx, nz, nf, ninf] = strawberry_newpopulation (x0,a,b,npop,f,constrained);
  endif
  pop = strawberry_sort (phi,nx,nz);
  gen = 0;

  if nz < 2
    best = pop(:,1);
  else
    best = [];
  endif
  bestgen = gen;
  nfunctionevaluations = npop; # initial population size

  if output
    printf("| %9s |", "gen")
    if nz > 1
      for i=1:nz, printf(" %6sy%02d |", "", i); endfor
      for i=1:nz, printf(" %6sy%02d |", "", i); endfor
    else
      for i=1:nx; printf(" %6sx%02d |", "", i); endfor
      for i=1:nz; printf(" %6sy%02d |", "", i); endfor
      if constrained; printf(" %9s |", "c"); endif
    endif
    printf(" %9s | %9s | %9s |", "$n_f$", "CPU (s)", "Best found")
    printf("\n");
    printf("|-\n");
  endif
#+end_src
** COMMENT prune population, removing infeasible solutions and multiple copies
#+name: prune
#+begin_src octave :noweb yes
  if nz > 1
    ## remove infeasible solutions from the population
    fitindices = pop(nx+1,:) < 1e19;
    if sum(fitindices) < size(pop,2)
      fprintf(stderr, "Removing %d solutions from population of %d.  \n", size(pop,2)-sum(fitindices), size(pop,2))
      pop = pop(:,fitindices);
    endif
  endif
  ## prune the solution, removing duplicate members as they contribute nothing
  pop = strawberry_prune (pop, nx, nz);
#+end_src
** COMMENT find best members of the population
The fitness method is used to find the best members of the population and assign each one a ranking N \in (0,1) with higher values better than lower values.  

In the multi-objective case, the pareto front is combined with the elite set, a new pareto front is identified and duplicates are removed.  The elite set does not get involved in the selection and propagation.
#+name: findbest
#+begin_src octave :noweb yes
  ## evaluate the fitness of the population.  For multi-objective problems,
  ## this has the side effect of returning the pareto front 
  [N pareto] = strawberry_fitness (pop,nx,nz,size(pop,2));
  ## keep track of best.  For multi-objective problems, this means keeping the pareto set
  debugprint(1, "best", best)
  debugprint(1, "pareto", pareto)
  debugprint(1, "pop(1)", pop(:,1))
  debugprint(1, "nx, nz", [nx, nz])
  if nz < 2 && pareto(nx+1) < best(nx+1) && norm(abs(best(1:nx)-pareto(1:nx))) > 1e-6
    best = pareto;
    bestgen = gen;
    ## zzz = zfit (best (1:nx))
    if !output
      printf("\n... new best solution at generation %d, z(1)=%g x=", gen, best(nx+1));
      printf("%g ", best(1:nx));
      printf("\n");
    endif
  elseif nz>1
    ## the set of points returned by the fitness function is not really
    ## a pareto set.  it is one point for each criterion.  we compare
    ## these points to the existing ones and update if necessary.
    if isempty(best)
      best = pareto;
    else
      if size(pareto,2) > 1 && size(best,2) > 1
        for i = 1:2
          if pareto(nx+i,i) < best(nx+i,i)
            best(:,i) = pareto(:,i);
            bestgen = gen;
          endif
        endfor
      else
        if pareto(nx+1,1) < best(nx+1,1)
          best(:,1) = pareto(:,1);
          bestgen = gen;
        endif
      endif
    endif
    debugprint (1, "size of pareto: ", length(best))
  endif
#+end_src
** COMMENT output results during iteration
#+name: iterationoutput
#+begin_src octave :noweb yes
  if 0 == mod(gen,output)
    if strawberry_numberofprocessors > 1
      dtime = time-starttime;
    else
      dtime = cputime-starttime;
    endif
    fprintf(stderr, "\r");
    printf("| %9d |", gen);
    if nz > 1
      printf (" %9.3g |", best(nx+1:nx+nz,1), best(nx+1:nx+nz,end))
      printf(" %9d | %9.1f | %9d |", nfunctionevaluations, dtime, bestgen);
    else
      printf (" %9.3g |", best(1:nx+nz))
      if constrained; printf(" %9.3g |", best(nx+nz+1)); endif
      printf(" %8d | %8.1f | %8d |", nfunctionevaluations, dtime, bestgen);
    endif
    printf("\n");
  else
    if nz > 1
      ## [fitness pareto] = moga_fitness (pop(1:nx,:), pop(nx+1:nx+nz,:));
      fprintf(stderr, "\r%30s %7d %3d/%4d %9.3g %9.3g %9.3g %9.3g", "", gen, size(best,2), length(pop), best(nx+1:nx+nz,1), best(nx+1:nx+nz,end))
    else
      if constrained
        fprintf(stderr, "\r%30s %9d [%9d] %5d %13.6e %13.6e ", "", gen, bestgen, length(pop), best(nx+nz), best(nx+nz+1));
      else
        fprintf(stderr, "\r%30s %9d [%9d] %5d %8d %13.6e ", "", "", gen, bestgen, length(pop), nfunctionevaluations, best(nx+nz));
      endif
    endif
  endif

  debugprint (1,"strawberry: fitness", N);
  actualnpop = size(pop,2);
  if actualnpop < size (pop,2)
    printf("Ummmm size of population %d is less than expected (%d)\n", size(1,pop), npop);
  endif
#+end_src
** COMMENT select and evaluate
#+name: selectandevaluate
#+begin_src octave :noweb yes
  ## generate all the new points and then evaluate them in parallel
  n = 1;
  newpop = [];
  selected = [];
  for p=1:npop                # we pick up to NPOP members to propagate
    s = strawberry_select (N);
    debugprint(2,"selected index", s)
    if s > 0
      selected(:,p) = pop(:,s);   # selected members remain for next generation; others die off
      debugprint(3, "selected fitness and point: ", [N(s), pop(:,s)']);
      nr = strawberry_runners (N(s),nrmax); # number of runners
      debugprint(2,": number of runners", nr)
      for r=1:nr
        dx = (b-a)/2 .* strawberry_distance (N(s),nx); # how far to run
        ## fprintf(stderr, "Selected %d with fitness %g to move %g\n", s, N(s), norm(dx))
        debugprint(3, ": r and dx", [r; dx(1:nx)])
        x = pop(1:nx,s)+dx;
        x(x<a) = a(x<a);        # reset boundary
        x(x>b) = b(x>b);        # reset boundary
        ## if strawberry_isdiverse(newpop,x)
        newpop{n} = x;
        n = n + 1;
        debugprint(2, ": added new member to population: ", x)
        ## endif
      endfor
      ## set fitness so this member is not selected again
      N(s) = -1;
    endif
  endfor
  debugprint(1,"Size of selected set: ", size(selected))
  debugprint(1,"Size of newpop: ", size(newpop))
  ## evaluate these in parallel using an appropriate number of processors
  ##parf = @(x) if length(x)>nx, x', else [x, f(x), 0]', endif
  ##phi = parcellfun (strawberry_numberofprocessors, parf, newpop)';

  if strawberry_numberofprocessors > 1
    phi = parcellfun (strawberry_numberofprocessors, @(x) [x; f(x); g(x)], newpop, "VerboseLevel", 0);
  else
    n = length(newpop);
    x = newpop{1};
    y = f(x);
    phi = zeros(length(x)+length(y)+1,n);
    phi(:,1) = [x;y;g(x)];
    for i=2:n
      x = newpop{i};
      phi(:,i) = [x;f(x);g(x)];
    end
  end
  nfunctionevaluations = nfunctionevaluations + length(phi);
  debugprint (1, ": phi before removal of infeasible solutions", phi)
  phi = phi(:,phi(nx+1,:)<1e19);
  debugprint (1, ": phi after removal of infeasible solutions", phi)
#+end_src
** COMMENT improve with local search
#+name: localmosd
#+begin_src octave :noweb yes
  ## try to improve each of the new solutions using a local search
  ## procedure, or maybe only a single step or so of that procedure.
  ## for i=1:length(phi)
  ##   sdpop{i} = phi(1:nx,i);
  ## endfor
  ## function point = mosderrorhandler (s, f, x, a, b)
  ##   printf("Error %d: index %d message=%s\n: ", s.identifier, s.index, s.message)
  ## endfunction
  ## improvedset = parcellfun (strawberry_numberofprocessors, @(x) [mosd(f,x,a,b)], sdpop, "ErrorHandler", @mosderrorhandler);

  ## as we cannot figure out how to get parcellfun to do what we want, we use sequential processing here for the time being
  sdphi = zeros(size(phi));
  for i=1:size(phi,2)
    sdphi(:,i) = mosd (f, phi(1:nx,i), a, b);
  endfor
  ## combine the two and hope diversity check removes duplicates
  phi = [phi, sdphi];
#+end_src
** COMMENT create new population
#+name: newpopulation
#+begin_src octave :noweb yes
  ## sort the population, which is composed of the original NPOP
  ## best plus those created in this loop, using the fitness for
  ## sorting.
  ## we have three sets of solutions that we can combine to create a
  ## new population:
  ## 1. the best overall so far
  ## 2. the members selected from the previous generation for propagation
  ## 3. and the new propagated solutions
  ## there are therefore 3! combinations although we always should
  ## include the new solutions so really have 4 different options:
  ## new alone, new with best, new with selected and new with
  ## selected and best.

  ## fprintf(stderr, "size best=%d selected=%d phi=%d\n", size(best,2), size(selected,2), size(phi,2));
  switch (population_strategy)
    case 1               # new members alone
      pop = phi;
    case 2               # new with selected
      pop = [selected, phi];
    case 3               # new with best
      pop = [best, phi];
    case 4               # new with best and selected
      pop = [best, selected, phi];
    otherwise
      printf("Error: population strategy %d not recognised.", population_strategy)
  endswitch
#+end_src
** COMMENT finish up
#+name: finish
#+begin_src octave :noweb yes
  if gen < ngen
    printf("Strawberry: terminating condition satisfied due to lack of improvement at gen=%d\n", gen);
  endif
  if output
    printf("Strawberry: at end, nf=%d ninf=%d best solution:\n", nf, ninf)
    disp(best);
  endif
  ## ensure the best solution is returned
  pop = [best, pop];
  x = pop(1:nx,:);
  y = pop(nx+1:end,:);
  if strawberry_numberofprocessors > 1
    endtime = time;            # wall clock time
  else
    endtime = cputime;
  endif
  printf("\n: strawberry method elapsed time: %.1f with %d functions evaluated and %d solutions pruned with %d similar.\n", 
         endtime-starttime, nfunctionevaluations, npruned, nsimilar)
  printf("MOSD improvements: %d\n", mosd_numberimproved);
#+end_src
* tests
** general bicriteria test
#+begin_src octave :tangle no
strawberry_test
#+end_src 
#+begin_src octave :tangle strawberry_test.m
  function [x z pareto fitness] = strawberry_test
    global esfdebug
    esfdebug = 0
    global strawberry_numberofprocessors
    strawberry_numberofprocessors = 1;
    f = @(x) [ sum((x-0.5).^2+1)
               sum(cos(x))];
    x0 = [0 0 0 0 0]';
    a = zeros(5,1);
    b = ones(5,1);
    printf('Testing bicriteria problem with %d decision variables\n', length(x0))
    printf('starting with initial point '), x0
    z0 = f(x0)
    printf('which has objective %d function values ', length(z0))
    for i=1:length(z0), printf("%f ", z0(i)), endfor; printf("\n")
    ## [x y nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output, g)
    [x z nf ninf bestgen] = strawberry(x0, a, b, f, 200, 50);
    paretoset = z(1:2, findpareto(z(1:2,:)));
    [zz indices] = sort(paretoset(1,:));
    paretoset = paretoset(:,indices)
    plot(paretoset(1,:),paretoset(2,:),'- r',z(1,:),z(2,:),' *g')
#+end_src
** three criteria test
This is simple test of three criteria.  The results can be seen in the following plot which shows the solutions in the Pareto set at the end.

#+begin_src gnuplot :results file :export results :file "strawberry_test3.png"
  reset
  unset key
  set xlabel 'f_1'
  set ylabel 'f_2'
  set zlabel 'f_3'
  set xyplane 0
  set xrange [4.75:6.6]
  set xtics 5,0.5
  set yrange [2.5:5.25]
  set ytics 3,0.5
  set zrange [0:6]
  set ztics 0,2
  set view 50,280
  splot 'strawberry_test3.data' with impulses
#+end_src 

#+results:
[[file:strawberry_test3.png]]

#+begin_src octave :tangle strawberry_test3.m
  function [x z paretoset] = strawberry_test3
    global esfdebug
    esfdebug = 0
    global strawberry_numberofprocessors
    strawberry_numberofprocessors = 1;
    global strawberry_fitness_method
    strawberry_fitness_method = 0
    f = @(x) [ sum((x-0.5).^2+1)
               sum(cos(x))
               sum(sin(x))];
    x0 = [0 0 0 0 0]';
    a = zeros(5,1);
    b = ones(5,1);
    printf('Testing three criteria problem with %d decision variables\n', length(x0))
    printf('starting with initial point '), x0
    z0 = f(x0);
    printf('which has objective %d function values ', length(z0))
    for i=1:length(z0), printf("%f ", z0(i)), endfor; printf("\n")
    ## [x y nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output, g)
    [x z nf ninf bestgen] = strawberry(x0, a, b, f, 1000, 20)
    paretoset = z(1:3, findpareto(z(1:3,:)));
    [zz indices] = sort(paretoset(1,:));
    paretoset = paretoset(:,indices)
    plot3(paretoset(1,:),paretoset(2,:), paretoset(3,:),'- r',z(1,:),z(2,:), z(3,:),' *g')
#+end_src
** testing the use of a mapping for mixed integer problems
The assumption is that Strawberry itself needs no special knowledge to work with integer variables.  The problem encoded here is from [[file:~/hg/jacaranda/inputs/minlp/westerlund/icheap6.in][Westerlund]].
#+begin_src octave :results output :tangle "mitest.m"
  global esfdebug
  esfdebug = 0
  global strawberry_numberofprocessors
  strawberry_numberofprocessors = 1;
  f = @(x) 3*round(x(2))-5*x(1);
  ## define the inequality contraints. this is a set of equations
  ## where the last expression should evaluate to a vector of
  ## values. A feasible point is one for which all the values in this
  ## vector are non-positive.
  g = @(x) any([ 2*round(x(2)) + 3*x(1) - 24;
             3*x(1) - 2*round(x(2)) - 8;
             2*round(x(2))^2 - 2*sqrt(round(x(2))) + 11*round(x(2)) + 8*x(1) - 39 - 2*sqrt(x(1))*round(x(2))^2 ] > 0);
  a = [1;1];
  b = [6;6];
  ## results = [];
  ## for i = 1:20
  ##   x = a + rand(1,2).*(b-a);
  ##   results = [results ; x, f(x), g(x)];
  ## endfor
  ## results
  x0 = [4;1.32];
  ngen = 100;
  npop = 10;
  nrmax = 5;
  ns = 1000;                       #number of stable generations
  population_strategy = 4;
  output = 10;
  [x y nf ninf bestgen] = strawberry(x0, a, b, f, ngen, npop, nrmax, ns, population_strategy, output, g)
#+end_src 

#+results:

* Recent change history
#+begin_src shell :exports results :results output
hg log --template "{date|shortdate} {desc|firstline}\n" --limit 10
#+end_src
* settings                                                    :noexport:
** emacs local variables
# Local Variables:
# time-stamp-line-limit: 1000
# time-stamp-format: "%04y.%02m.%02d %02H:%02M:%02S"
# time-stamp-active: t
# time-stamp-start: "version = \""
# time-stamp-end: "\";"
# End:
